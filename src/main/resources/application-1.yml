? ''
  : ':1 # Regular expression that matches proxies that are to be trusted.'
'0': 0:0:0:0:0:0:1\
127\:
  \d{1,3}\:
    \d{1,3}\:
      \d{1,3}|\: ''
169\:
  254\:
    \d{1,3}\:
      \d{1,3}|\: ''
172\:
  1[6-9]{1}\:
    \d{1,3}\:
      \d{1,3}|\: ''
  2[0-9]{1}\:
    \d{1,3}\:
      \d{1,3}|\: ''
  3[0-1]{1}\:
    \d{1,3}\:
      \d{1,3}\: ''
192\:
  168\:
    \d{1,3}\:
      \d{1,3}|\: ''
debug: 'false # Enable debug logs.'
info: '# Arbitrary properties to add to the info endpoint.'
logging:
  config: '# Location of the logging configuration file. For instance, `classpath:logback.xml`
    for Logback.'
  exception-conversion-word: '%wEx # Conversion word used when logging exceptions.'
  file: '# Log file name (for instance, `myapp.log`). Names can be an exact location
    or relative to the current directory.'
  file.max-history: '0 # Maximum of archive log files to keep. Only supported with
    the default logback setup.'
  group:
    '*': '# Log groups to quickly change multiple loggers at the same time. For instance,
      `logging.level.db=org.hibernate,org.springframework.jdbc`.'
  level:
    '*': '# Log levels severity mapping. For instance, `logging.level.org.springframework=DEBUG`.'
  path: '# Location of the log file. For instance, `/var/log`.'
  pattern:
    console: '# Appender pattern for output to the console. Supported only with the
      default Logback setup.'
    dateformat: 'yyyy-MM-dd HH:mm:ss.SSS # Appender pattern for log date format. Supported
      only with the default Logback setup.'
    file: '# Appender pattern for output to a file. Supported only with the default
      Logback setup.'
    level: '%5p # Appender pattern for log level. Supported only with the default
      Logback setup.'
  register-shutdown-hook: 'false # Register a shutdown hook for the logging system
    when it is initialized.'
management:
  cloudfoundry:
    enabled: 'true # Whether to enable extended Cloud Foundry actuator endpoints.'
    skip-ssl-validation: 'false # Whether to skip SSL verification for Cloud Foundry
      actuator endpoint security calls.'
  endpoint:
    auditevents:
      cache:
        time-to-live: '0ms # Maximum time that a response can be cached.'
      enabled: 'true # Whether to enable the auditevents endpoint.'
    beans:
      cache:
        time-to-live: '0ms # Maximum time that a response can be cached.'
      enabled: 'true # Whether to enable the beans endpoint.'
    caches:
      cache:
        time-to-live: '0ms # Maximum time that a response can be cached.'
      enabled: 'true # Whether to enable the caches endpoint.'
    conditions:
      cache:
        time-to-live: '0ms # Maximum time that a response can be cached.'
      enabled: 'true # Whether to enable the conditions endpoint.'
    configprops:
      cache:
        time-to-live: '0ms # Maximum time that a response can be cached.'
      enabled: 'true # Whether to enable the configprops endpoint.'
      keys-to-sanitize: 'password,secret,key,token,.*credentials.*,vcap_services,sun.java.command
        # Keys that should be sanitized. Keys can be simple strings that the property
        ends with or regular expressions.'
    env:
      cache:
        time-to-live: '0ms # Maximum time that a response can be cached.'
      enabled: 'true # Whether to enable the env endpoint.'
      keys-to-sanitize: 'password,secret,key,token,.*credentials.*,vcap_services,sun.java.command
        # Keys that should be sanitized. Keys can be simple strings that the property
        ends with or regular expressions.'
    flyway:
      cache:
        time-to-live: '0ms # Maximum time that a response can be cached.'
      enabled: 'true # Whether to enable the flyway endpoint.'
    health:
      cache:
        time-to-live: '0ms # Maximum time that a response can be cached.'
      enabled: 'true # Whether to enable the health endpoint.'
      roles: '# Roles used to determine whether or not a user is authorized to be
        shown details. When empty, all authenticated users are authorized.'
      show-details: 'never # When to show full health details.'
    heapdump:
      cache:
        time-to-live: '0ms # Maximum time that a response can be cached.'
      enabled: 'true # Whether to enable the heapdump endpoint.'
    httptrace:
      cache:
        time-to-live: '0ms # Maximum time that a response can be cached.'
      enabled: 'true # Whether to enable the httptrace endpoint.'
    info:
      cache:
        time-to-live: '0ms # Maximum time that a response can be cached.'
      enabled: 'true # Whether to enable the info endpoint.'
    integrationgraph:
      cache:
        time-to-live: '0ms # Maximum time that a response can be cached.'
      enabled: 'true # Whether to enable the integrationgraph endpoint.'
    jolokia:
      config:
        '*': '# Jolokia settings. Refer to the documentation of Jolokia for more details.'
      enabled: 'true # Whether to enable the jolokia endpoint.'
    liquibase:
      cache:
        time-to-live: '0ms # Maximum time that a response can be cached.'
      enabled: 'true # Whether to enable the liquibase endpoint.'
    logfile:
      cache:
        time-to-live: '0ms # Maximum time that a response can be cached.'
      enabled: 'true # Whether to enable the logfile endpoint.'
      external-file: '# External Logfile to be accessed. Can be used if the logfile
        is written by output redirect and not by the logging system itself.'
    loggers:
      cache:
        time-to-live: '0ms # Maximum time that a response can be cached.'
      enabled: 'true # Whether to enable the loggers endpoint.'
    mappings:
      cache:
        time-to-live: '0ms # Maximum time that a response can be cached.'
      enabled: 'true # Whether to enable the mappings endpoint.'
    metrics:
      cache:
        time-to-live: '0ms # Maximum time that a response can be cached.'
      enabled: 'true # Whether to enable the metrics endpoint.'
    prometheus:
      cache:
        time-to-live: '0ms # Maximum time that a response can be cached.'
      enabled: 'true # Whether to enable the prometheus endpoint.'
    scheduledtasks:
      cache:
        time-to-live: '0ms # Maximum time that a response can be cached.'
      enabled: 'true # Whether to enable the scheduledtasks endpoint.'
    sessions:
      enabled: 'true # Whether to enable the sessions endpoint.'
    shutdown:
      enabled: 'false # Whether to enable the shutdown endpoint.'
    threaddump:
      cache:
        time-to-live: '0ms # Maximum time that a response can be cached.'
      enabled: 'true # Whether to enable the threaddump endpoint.'
  endpoints:
    enabled-by-default: '# Whether to enable or disable all endpoints by default.'
    jmx:
      domain: 'org.springframework.boot # Endpoints JMX domain name. Fallback to ''spring.jmx.default-domain''
        if set.'
      exposure:
        exclude: '# Endpoint IDs that should be excluded or ''*'' for all.'
        include: '* # Endpoint IDs that should be included or ''*'' for all.'
      static-names: '# Additional static properties to append to all ObjectNames of
        MBeans representing Endpoints.'
    web:
      base-path: '/actuator # Base path for Web endpoints. Relative to server.servlet.context-path
        or management.server.servlet.context-path if management.server.port is configured.'
      cors:
        allow-credentials: '# Whether credentials are supported. When not set, credentials
          are not supported.'
        allowed-headers: '# Comma-separated list of headers to allow in a request.
          ''*'' allows all headers.'
        allowed-methods: '# Comma-separated list of methods to allow. ''*'' allows
          all methods. When not set, defaults to GET.'
        allowed-origins: '# Comma-separated list of origins to allow. ''*'' allows
          all origins. When not set, CORS support is disabled.'
        exposed-headers: '# Comma-separated list of headers to include in a response.'
        max-age: '1800s # How long the response from a pre-flight request can be cached
          by clients. If a duration suffix is not specified, seconds will be used.'
      exposure:
        exclude: '# Endpoint IDs that should be excluded or ''*'' for all.'
        include: 'health,info # Endpoint IDs that should be included or ''*'' for
          all.'
      path-mapping: '# Mapping between endpoint IDs and the path that should expose
        them.'
  health:
    cassandra:
      enabled: 'true # Whether to enable Cassandra health check.'
    couchbase:
      enabled: 'true # Whether to enable Couchbase health check.'
    db:
      enabled: 'true # Whether to enable database health check.'
    defaults:
      enabled: 'true # Whether to enable default health indicators.'
    diskspace:
      enabled: 'true # Whether to enable disk space health check.'
      path: '# Path used to compute the available disk space.'
      threshold: '10MB # Minimum disk space that should be available.'
    elasticsearch:
      enabled: 'true # Whether to enable Elasticsearch health check.'
      indices: '# Comma-separated index names.'
      response-timeout: '100ms # Time to wait for a response from the cluster.'
    influxdb:
      enabled: 'true # Whether to enable InfluxDB health check.'
    jms:
      enabled: 'true # Whether to enable JMS health check.'
    ldap:
      enabled: 'true # Whether to enable LDAP health check.'
    mail:
      enabled: 'true # Whether to enable Mail health check.'
    mongo:
      enabled: 'true # Whether to enable MongoDB health check.'
    neo4j:
      enabled: 'true # Whether to enable Neo4j health check.'
    rabbit:
      enabled: 'true # Whether to enable RabbitMQ health check.'
    redis:
      enabled: 'true # Whether to enable Redis health check.'
    solr:
      enabled: 'true # Whether to enable Solr health check.'
    status:
      http-mapping: '# Mapping of health statuses to HTTP status codes. By default,
        registered health statuses map to sensible defaults (for example, UP maps
        to 200).'
      order: 'DOWN,OUT_OF_SERVICE,UP,UNKNOWN # Comma-separated list of health statuses
        in order of severity.'
  info:
    build:
      enabled: 'true # Whether to enable build info.'
    defaults:
      enabled: 'true # Whether to enable default info contributors.'
    env:
      enabled: 'true # Whether to enable environment info.'
    git:
      enabled: 'true # Whether to enable git info.'
      mode: 'simple # Mode to use to expose git information.'
  metrics:
    distribution:
      maximum-expected-value:
        '*': '# Maximum value that meter IDs starting-with the specified name are
          expected to observe.'
      minimum-expected-value:
        '*': '# Minimum value that meter IDs starting-with the specified name are
          expected to observe.'
      percentiles:
        '*': '# Specific computed non-aggregable percentiles to ship to the backend
          for meter IDs starting-with the specified name.'
      percentiles-histogram:
        '*': '# Whether meter IDs starting with the specified name should publish
          percentile histograms.'
      sla:
        '*': '# Specific SLA boundaries for meter IDs starting-with the specified
          name. The longest match wins.'
    enable:
      '*': '# Whether meter IDs starting-with the specified name should be enabled.
        The longest match wins, the key `all` can also be used to configure all meters.'
    export:
      appoptics:
        api-token: '# AppOptics API token.'
        batch-size: '500 # Number of measurements per request to use for this backend.
          If more measurements are found, then multiple requests will be made.'
        connect-timeout: '5s # Connection timeout for requests to this backend.'
        enabled: 'true # Whether exporting of metrics to this backend is enabled.'
        host-tag: 'instance # Tag that will be mapped to "@host" when shipping metrics
          to AppOptics.'
        num-threads: '2 # Number of threads to use with the metrics publishing scheduler.'
        read-timeout: '10s # Read timeout for requests to this backend.'
        step: '1m # Step size (i.e. reporting frequency) to use.'
        uri: 'https://api.appoptics.com/v1/measurements # URI to ship metrics to.'
      atlas:
        batch-size: '10000 # Number of measurements per request to use for this backend.
          If more measurements are found, then multiple requests will be made.'
        config-refresh-frequency: '10s # Frequency for refreshing config settings
          from the LWC service.'
        config-time-to-live: '150s # Time to live for subscriptions from the LWC service.'
        config-uri: 'http://localhost:7101/lwc/api/v1/expressions/local-dev # URI
          for the Atlas LWC endpoint to retrieve current subscriptions.'
        connect-timeout: '1s # Connection timeout for requests to this backend.'
        enabled: 'true # Whether exporting of metrics to this backend is enabled.'
        eval-uri: 'http://localhost:7101/lwc/api/v1/evaluate # URI for the Atlas LWC
          endpoint to evaluate the data for a subscription.'
        lwc-enabled: 'false # Whether to enable streaming to Atlas LWC.'
        meter-time-to-live: '15m # Time to live for meters that do not have any activity.
          After this period the meter will be considered expired and will not get
          reported.'
        num-threads: '2 # Number of threads to use with the metrics publishing scheduler.'
        read-timeout: '10s # Read timeout for requests to this backend.'
        step: '1m # Step size (i.e. reporting frequency) to use.'
        uri: 'http://localhost:7101/api/v1/publish # URI of the Atlas server.'
      datadog:
        api-key: '# Datadog API key.'
        application-key: '# Datadog application key. Not strictly required, but improves
          the Datadog experience by sending meter descriptions, types, and base units
          to Datadog.'
        batch-size: '10000 # Number of measurements per request to use for this backend.
          If more measurements are found, then multiple requests will be made.'
        connect-timeout: '1s # Connection timeout for requests to this backend.'
        descriptions: 'true # Whether to publish descriptions metadata to Datadog.
          Turn this off to minimize the amount of metadata sent.'
        enabled: 'true # Whether exporting of metrics to this backend is enabled.'
        host-tag: 'instance # Tag that will be mapped to "host" when shipping metrics
          to Datadog.'
        num-threads: '2 # Number of threads to use with the metrics publishing scheduler.'
        read-timeout: '10s # Read timeout for requests to this backend.'
        step: '1m # Step size (i.e. reporting frequency) to use.'
        uri: 'https://app.datadoghq.com # URI to ship metrics to. If you need to publish
          metrics to an internal proxy en-route to Datadog, you can define the location
          of the proxy with this.'
      dynatrace:
        api-token: '# Dynatrace authentication token.'
        batch-size: '10000 # Number of measurements per request to use for this backend.
          If more measurements are found, then multiple requests will be made.'
        connect-timeout: '1s # Connection timeout for requests to this backend.'
        device-id: '# ID of the custom device that is exporting metrics to Dynatrace.'
        enabled: 'true # Whether exporting of metrics to this backend is enabled.'
        num-threads: '2 # Number of threads to use with the metrics publishing scheduler.'
        read-timeout: '10s # Read timeout for requests to this backend.'
        step: '1m # Step size (i.e. reporting frequency) to use.'
        technology-type: 'java # Technology type for exported metrics. Used to group
          metrics under a logical technology name in the Dynatrace UI.'
        uri: '# URI to ship metrics to. Should be used for SaaS, self managed instances
          or to en-route through an internal proxy.'
      elastic:
        auto-create-index: 'true # Whether to create the index automatically if it
          does not exist.'
        batch-size: '10000 # Number of measurements per request to use for this backend.
          If more measurements are found, then multiple requests will be made.'
        connect-timeout: '1s # Connection timeout for requests to this backend.'
        enabled: 'true # Whether exporting of metrics to this backend is enabled.'
        host: 'http://localhost:9200 # Host to export metrics to.'
        index: 'metrics # Index to export metrics to.'
        index-date-format: 'yyyy-MM # Index date format used for rolling indices.
          Appended to the index name, preceded by a ''-''.'
        num-threads: '2 # Number of threads to use with the metrics publishing scheduler.'
        password: '# Login password of the Elastic server.'
        read-timeout: '10s # Read timeout for requests to this backend.'
        step: '1m # Step size (i.e. reporting frequency) to use.'
        timestamp-field-name: '@timestamp # Name of the timestamp field.'
        user-name: '# Login user of the Elastic server.'
      ganglia:
        addressing-mode: 'multicast # UDP addressing mode, either unicast or multicast.'
        duration-units: 'milliseconds # Base time unit used to report durations.'
        enabled: 'true # Whether exporting of metrics to Ganglia is enabled.'
        host: 'localhost # Host of the Ganglia server to receive exported metrics.'
        port: '8649 # Port of the Ganglia server to receive exported metrics.'
        protocol-version: '3.1 # Ganglia protocol version. Must be either 3.1 or 3.0.'
        rate-units: 'seconds # Base time unit used to report rates.'
        step: '1m # Step size (i.e. reporting frequency) to use.'
        time-to-live: '1 # Time to live for metrics on Ganglia. Set the multi-cast
          Time-To-Live to be one greater than the number of hops (routers) between
          the hosts.'
      graphite:
        duration-units: 'milliseconds # Base time unit used to report durations.'
        enabled: 'true # Whether exporting of metrics to Graphite is enabled.'
        host: 'localhost # Host of the Graphite server to receive exported metrics.'
        port: '2004 # Port of the Graphite server to receive exported metrics.'
        protocol: 'pickled # Protocol to use while shipping data to Graphite.'
        rate-units: 'seconds # Base time unit used to report rates.'
        step: '1m # Step size (i.e. reporting frequency) to use.'
        tags-as-prefix: '# For the default naming convention, turn the specified tag
          keys into part of the metric prefix.'
      humio:
        api-token: '# Humio API token.'
        batch-size: '10000 # Number of measurements per request to use for this backend.
          If more measurements are found, then multiple requests will be made.'
        connect-timeout: '5s # Connection timeout for requests to this backend.'
        enabled: 'true # Whether exporting of metrics to this backend is enabled.'
        num-threads: '2 # Number of threads to use with the metrics publishing scheduler.'
        read-timeout: '10s # Read timeout for requests to this backend.'
        repository: 'sandbox # Name of the repository to publish metrics to.'
        step: '1m # Step size (i.e. reporting frequency) to use.'
        tags:
          '*': '# Humio tags describing the data source in which metrics will be stored.
            Humio tags are a distinct concept from Micrometer''s tags. Micrometer''s
            tags are used to divide metrics along dimensional boundaries.'
        uri: 'https://cloud.humio.com # URI to ship metrics to. If you need to publish
          metrics to an internal proxy en-route to Humio, you can define the location
          of the proxy with this.'
      influx:
        auto-create-db: 'true # Whether to create the Influx database if it does not
          exist before attempting to publish metrics to it.'
        batch-size: '10000 # Number of measurements per request to use for this backend.
          If more measurements are found, then multiple requests will be made.'
        compressed: 'true # Whether to enable GZIP compression of metrics batches
          published to Influx.'
        connect-timeout: '1s # Connection timeout for requests to this backend.'
        consistency: 'one # Write consistency for each point.'
        db: 'mydb # Tag that will be mapped to "host" when shipping metrics to Influx.'
        enabled: 'true # Whether exporting of metrics to this backend is enabled.'
        num-threads: '2 # Number of threads to use with the metrics publishing scheduler.'
        password: '# Login password of the Influx server.'
        read-timeout: '10s # Read timeout for requests to this backend.'
        retention-duration: '# Time period for which Influx should retain data in
          the current database.'
        retention-policy: '# Retention policy to use (Influx writes to the DEFAULT
          retention policy if one is not specified).'
        retention-replication-factor: '# How many copies of the data are stored in
          the cluster.'
        retention-shard-duration: '# Time range covered by a shard group.'
        step: '1m # Step size (i.e. reporting frequency) to use.'
        uri: 'http://localhost:8086 # URI of the Influx server.'
        user-name: '# Login user of the Influx server.'
      jmx:
        domain: 'metrics # Metrics JMX domain name.'
        enabled: 'true # Whether exporting of metrics to JMX is enabled.'
        step: '1m # Step size (i.e. reporting frequency) to use.'
      kairos:
        batch-size: '10000 # Number of measurements per request to use for this backend.
          If more measurements are found, then multiple requests will be made.'
        connect-timeout: '1s # Connection timeout for requests to this backend.'
        enabled: 'true # Whether exporting of metrics to this backend is enabled.'
        num-threads: '2 # Number of threads to use with the metrics publishing scheduler.'
        password: '# Login password of the KairosDB server.'
        read-timeout: '10s # Read timeout for requests to this backend.'
        step: '1m # Step size (i.e. reporting frequency) to use.'
        uri: 'localhost:8080/api/v1/datapoints # URI of the KairosDB server.'
        user-name: '# Login user of the KairosDB server.'
      newrelic:
        account-id: '# New Relic account ID.'
        api-key: '# New Relic API key.'
        batch-size: '10000 # Number of measurements per request to use for this backend.
          If more measurements are found, then multiple requests will be made.'
        connect-timeout: '1s # Connection timeout for requests to this backend.'
        enabled: 'true # Whether exporting of metrics to this backend is enabled.'
        num-threads: '2 # Number of threads to use with the metrics publishing scheduler.'
        read-timeout: '10s # Read timeout for requests to this backend.'
        step: '1m # Step size (i.e. reporting frequency) to use.'
        uri: 'https://insights-collector.newrelic.com # URI to ship metrics to.'
      prometheus:
        descriptions: 'true # Whether to enable publishing descriptions as part of
          the scrape payload to Prometheus. Turn this off to minimize the amount of
          data sent on each scrape.'
        enabled: 'true # Whether exporting of metrics to Prometheus is enabled.'
        pushgateway:
          base-url: 'localhost:9091 # Base URL for the Pushgateway.'
          enabled: 'false # Enable publishing via a Prometheus Pushgateway.'
          grouping-key: '# Grouping key for the pushed metrics.'
          job: '# Job identifier for this application instance.'
          push-rate: '1m # Frequency with which to push metrics.'
          shutdown-operation: '# Operation that should be performed on shutdown.'
        step: '1m # Step size (i.e. reporting frequency) to use.'
      signalfx:
        access-token: '# SignalFX access token.'
        batch-size: '10000 # Number of measurements per request to use for this backend.
          If more measurements are found, then multiple requests will be made.'
        connect-timeout: '1s # Connection timeout for requests to this backend.'
        enabled: 'true # Whether exporting of metrics to this backend is enabled.'
        num-threads: '2 # Number of threads to use with the metrics publishing scheduler.'
        read-timeout: '10s # Read timeout for requests to this backend.'
        source: '# Uniquely identifies the app instance that is publishing metrics
          to SignalFx. Defaults to the local host name.'
        step: '10s # Step size (i.e. reporting frequency) to use.'
        uri: 'https://ingest.signalfx.com # URI to ship metrics to.'
      simple:
        enabled: 'true # Whether, in the absence of any other exporter, exporting
          of metrics to an in-memory backend is enabled.'
        mode: 'cumulative # Counting mode.'
        step: '1m # Step size (i.e. reporting frequency) to use.'
      statsd:
        enabled: 'true # Whether exporting of metrics to StatsD is enabled.'
        flavor: 'datadog # StatsD line protocol to use.'
        host: 'localhost # Host of the StatsD server to receive exported metrics.'
        max-packet-length: '1400 # Total length of a single payload should be kept
          within your network''s MTU.'
        polling-frequency: '10s # How often gauges will be polled. When a gauge is
          polled, its value is recalculated and if the value has changed (or publishUnchangedMeters
          is true), it is sent to the StatsD server.'
        port: '8125 # Port of the StatsD server to receive exported metrics.'
        publish-unchanged-meters: 'true # Whether to send unchanged meters to the
          StatsD server.'
      wavefront:
        api-token: '# API token used when publishing metrics directly to the Wavefront
          API host.'
        batch-size: '10000 # Number of measurements per request to use for this backend.
          If more measurements are found, then multiple requests will be made.'
        connect-timeout: '1s # Connection timeout for requests to this backend.'
        enabled: 'true # Whether exporting of metrics to this backend is enabled.'
        global-prefix: '# Global prefix to separate metrics originating from this
          app''s white box instrumentation from those originating from other Wavefront
          integrations when viewed in the Wavefront UI.'
        num-threads: '2 # Number of threads to use with the metrics publishing scheduler.'
        read-timeout: '10s # Read timeout for requests to this backend.'
        source: '# Unique identifier for the app instance that is the source of metrics
          being published to Wavefront. Defaults to the local host name.'
        step: '10s # Step size (i.e. reporting frequency) to use.'
        uri: 'https://longboard.wavefront.com # URI to ship metrics to.'
    tags:
      '*': '# Common tags that are applied to every meter.'
    use-global-registry: 'true # Whether auto-configured MeterRegistry implementations
      should be bound to the global static registry on Metrics.'
    web:
      client:
        max-uri-tags: '100 # Maximum number of unique URI tag values allowed. After
          the max number of tag values is reached, metrics with additional tag values
          are denied by filter.'
        requests-metric-name: 'http.client.requests # Name of the metric for sent
          requests.'
      server:
        auto-time-requests: 'true # Whether requests handled by Spring MVC, WebFlux
          or Jersey should be automatically timed.'
        max-uri-tags: '100 # Maximum number of unique URI tag values allowed. After
          the max number of tag values is reached, metrics with additional tag values
          are denied by filter.'
        requests-metric-name: 'http.server.requests # Name of the metric for received
          requests.'
  server:
    add-application-context-header: 'false # Add the "X-Application-Context" HTTP
      header in each response.'
    address: '# Network address to which the management endpoints should bind. Requires
      a custom management.server.port.'
    port: '# Management endpoint HTTP port (uses the same port as the application
      by default). Configure a different port to use management-specific SSL.'
    servlet:
      context-path: '# Management endpoint context-path (for instance, `/management`).
        Requires a custom management.server.port.'
    ssl:
      ciphers: '# Supported SSL ciphers.'
      client-auth: '# Client authentication mode.'
      enabled: 'true # Whether to enable SSL support.'
      enabled-protocols: '# Enabled SSL protocols.'
      key-alias: '# Alias that identifies the key in the key store.'
      key-password: '# Password used to access the key in the key store.'
      key-store: '# Path to the key store that holds the SSL certificate (typically
        a jks file).'
      key-store-password: '# Password used to access the key store.'
      key-store-provider: '# Provider for the key store.'
      key-store-type: '# Type of the key store.'
      protocol: 'TLS # SSL protocol to use.'
      trust-store: '# Trust store that holds SSL certificates.'
      trust-store-password: '# Password used to access the trust store.'
      trust-store-provider: '# Provider for the trust store.'
      trust-store-type: '# Type of the trust store.'
  trace:
    http:
      enabled: 'true # Whether to enable HTTP request-response tracing.'
      include: 'request-headers,response-headers,cookies,errors # Items to be included
        in the trace.'
server:
  address: '# Network address to which the server should bind.'
  compression:
    enabled: 'false # Whether response compression is enabled.'
    excluded-user-agents: '# Comma-separated list of user agents for which responses
      should not be compressed.'
    mime-types: 'text/html,text/xml,text/plain,text/css,text/javascript,application/javascript,application/json,application/xml
      # Comma-separated list of MIME types that should be compressed.'
    min-response-size: '2KB # Minimum "Content-Length" value that is required for
      compression to be performed.'
  connection-timeout: '# Time that connectors wait for another HTTP request before
    closing the connection. When not set, the connector''s container-specific default
    is used. Use a value of -1 to indicate no (that is, an infinite) timeout.'
  error:
    include-exception: 'false # Include the "exception" attribute.'
    include-stacktrace: 'never # When to include a "stacktrace" attribute.'
    path: '/error # Path of the error controller.'
    whitelabel:
      enabled: 'true # Whether to enable the default error page displayed in browsers
        in case of a server error.'
  http2:
    enabled: 'false # Whether to enable HTTP/2 support, if the current environment
      supports it.'
  jetty:
    acceptors: '-1 # Number of acceptor threads to use. When the value is -1, the
      default, the number of acceptors is derived from the operating environment.'
    accesslog:
      append: 'false # Append to log.'
      date-format: 'dd/MMM/yyyy:HH:mm:ss Z # Timestamp format of the request log.'
      enabled: 'false # Enable access log.'
      extended-format: 'false # Enable extended NCSA format.'
      file-date-format: '# Date format to place in log file name.'
      filename: '# Log filename. If not specified, logs redirect to "System.err".'
      locale: '# Locale of the request log.'
      log-cookies: 'false # Enable logging of the request cookies.'
      log-latency: 'false # Enable logging of request processing time.'
      log-server: 'false # Enable logging of the request hostname.'
      retention-period: '31 # Number of days before rotated log files are deleted.'
      time-zone: 'GMT # Timezone of the request log.'
    max-http-post-size: '200000B # Maximum size of the HTTP post or put content.'
    selectors: '-1 # Number of selector threads to use. When the value is -1, the
      default, the number of selectors is derived from the operating environment.'
  max-http-header-size: '8KB # Maximum size of the HTTP message header.'
  port: '8080 # Server HTTP port.'
  server-header: '# Value to use for the Server response header (if empty, no header
    is sent).'
  servlet:
    application-display-name: 'application # Display name of the application.'
    context-parameters:
      '*': '# Servlet context init parameters.'
    context-path: '# Context path of the application.'
    jsp:
      class-name: 'org.apache.jasper.servlet.JspServlet # Class name of the servlet
        to use for JSPs.'
      init-parameters:
        '*': '# Init parameters used to configure the JSP servlet.'
      registered: 'true # Whether the JSP servlet is registered.'
    session:
      cookie:
        comment: '# Comment for the session cookie.'
        domain: '# Domain for the session cookie.'
        http-only: '# Whether to use "HttpOnly" cookies for session cookies.'
        max-age: '# Maximum age of the session cookie. If a duration suffix is not
          specified, seconds will be used.'
        name: '# Session cookie name.'
        path: '# Path of the session cookie.'
        secure: '# Whether to always mark the session cookie as secure.'
      persistent: 'false # Whether to persist session data between restarts.'
      store-dir: '# Directory used to store session data.'
      timeout: '30m # Session timeout. If a duration suffix is not specified, seconds
        will be used.'
      tracking-modes: '# Session tracking modes.'
  ssl:
    ciphers: '# Supported SSL ciphers.'
    client-auth: '# Client authentication mode.'
    enabled: 'true # Whether to enable SSL support.'
    enabled-protocols: '# Enabled SSL protocols.'
    key-alias: '# Alias that identifies the key in the key store.'
    key-password: '# Password used to access the key in the key store.'
    key-store: '# Path to the key store that holds the SSL certificate (typically
      a jks file).'
    key-store-password: '# Password used to access the key store.'
    key-store-provider: '# Provider for the key store.'
    key-store-type: '# Type of the key store.'
    protocol: 'TLS # SSL protocol to use.'
    trust-store: '# Trust store that holds SSL certificates.'
    trust-store-password: '# Password used to access the trust store.'
    trust-store-provider: '# Provider for the trust store.'
    trust-store-type: '# Type of the trust store.'
  tomcat:
    accept-count: '100 # Maximum queue length for incoming connection requests when
      all possible request processing threads are in use.'
    accesslog:
      buffered: 'true # Whether to buffer output such that it is flushed only periodically.'
      directory: 'logs # Directory in which log files are created. Can be absolute
        or relative to the Tomcat base dir.'
      enabled: 'false # Enable access log.'
      file-date-format: '.yyyy-MM-dd # Date format to place in the log file name.'
      pattern: 'common # Format pattern for access logs.'
      prefix: 'access_log # Log file name prefix.'
      rename-on-rotate: 'false # Whether to defer inclusion of the date stamp in the
        file name until rotate time.'
      request-attributes-enabled: 'false # Set request attributes for the IP address,
        Hostname, protocol, and port used for the request.'
      rotate: 'true # Whether to enable access log rotation.'
      suffix: '.log # Log file name suffix.'
    additional-tld-skip-patterns: '# Comma-separated list of additional patterns that
      match jars to ignore for TLD scanning.'
    background-processor-delay: '10s # Delay between the invocation of backgroundProcess
      methods. If a duration suffix is not specified, seconds will be used.'
    basedir: '# Tomcat base directory. If not specified, a temporary directory is
      used.'
    internal-proxies: 10\.\d{1,3}\.\d{1,3}\.\d{1,3}|\
    max-connections: '10000 # Maximum number of connections that the server accepts
      and processes at any given time.'
    max-http-post-size: '2MB # Maximum size of the HTTP post content.'
    max-swallow-size: '2MB # Maximum amount of request body to swallow.'
    max-threads: '200 # Maximum amount of worker threads.'
    min-spare-threads: '10 # Minimum amount of worker threads.'
    port-header: 'X-Forwarded-Port # Name of the HTTP header used to override the
      original port value.'
    protocol-header: '# Header that holds the incoming protocol, usually named "X-Forwarded-Proto".'
    protocol-header-https-value: 'https # Value of the protocol header indicating
      whether the incoming request uses SSL.'
    redirect-context-root: 'true # Whether requests to the context root should be
      redirected by appending a / to the path.'
    remote-ip-header: '# Name of the HTTP header from which the remote IP is extracted.
      For instance, `X-FORWARDED-FOR`.'
    resource:
      allow-caching: 'true # Whether static resource caching is permitted for this
        web application.'
      cache-ttl: '# Time-to-live of the static resource cache.'
    uri-encoding: 'UTF-8 # Character encoding to use to decode the URI.'
    use-relative-redirects: '# Whether HTTP 1.1 and later location headers generated
      by a call to sendRedirect will use relative or absolute redirects.'
  undertow:
    accesslog:
      dir: '# Undertow access log directory.'
      enabled: 'false # Whether to enable the access log.'
      pattern: 'common # Format pattern for access logs.'
      prefix: 'access_log. # Log file name prefix.'
      rotate: 'true # Whether to enable access log rotation.'
      suffix: 'log # Log file name suffix.'
    buffer-size: '# Size of each buffer.'
    direct-buffers: '# Whether to allocate buffers outside the Java heap. The default
      is derived from the maximum amount of memory that is available to the JVM.'
    eager-filter-init: 'true # Whether servlet filters should be initialized on startup.'
    io-threads: '# Number of I/O threads to create for the worker. The default is
      derived from the number of available processors.'
    max-http-post-size: '-1B # Maximum size of the HTTP post content. When the value
      is -1, the default, the size is unlimited.'
    worker-threads: '# Number of worker threads. The default is 8 times the number
      of I/O threads.'
  use-forward-headers: '# Whether X-Forwarded-* headers should be applied to the HttpRequest.'
spring:
  activemq:
    broker-url: '# URL of the ActiveMQ broker. Auto-generated by default.'
    close-timeout: '15s # Time to wait before considering a close complete.'
    in-memory: 'true # Whether the default broker URL should be in memory. Ignored
      if an explicit broker has been specified.'
    non-blocking-redelivery: 'false # Whether to stop message delivery before re-delivering
      messages from a rolled back transaction. This implies that message order is
      not preserved when this is enabled.'
    packages:
      trust-all: '# Whether to trust all packages.'
      trusted: '# Comma-separated list of specific packages to trust (when not trusting
        all packages).'
    password: '# Login password of the broker.'
    pool:
      block-if-full: 'true # Whether to block when a connection is requested and the
        pool is full. Set it to false to throw a "JMSException" instead.'
      block-if-full-timeout: '-1ms # Blocking period before throwing an exception
        if the pool is still full.'
      enabled: 'false # Whether a JmsPoolConnectionFactory should be created, instead
        of a regular ConnectionFactory.'
      idle-timeout: '30s # Connection idle timeout.'
      max-connections: '1 # Maximum number of pooled connections.'
      max-sessions-per-connection: '500 # Maximum number of pooled sessions per connection
        in the pool.'
      time-between-expiration-check: '-1ms # Time to sleep between runs of the idle
        connection eviction thread. When negative, no idle connection eviction thread
        runs.'
      use-anonymous-producers: 'true # Whether to use only one anonymous "MessageProducer"
        instance. Set it to false to create one "MessageProducer" every time one is
        required.'
    send-timeout: '0ms # Time to wait on message sends for a response. Set it to 0
      to wait forever.'
    user: '# Login user of the broker.'
  aop:
    auto: 'true # Add @EnableAspectJAutoProxy.'
    proxy-target-class: 'true # Whether subclass-based (CGLIB) proxies are to be created
      (true), as opposed to standard Java interface-based proxies (false).'
  application:
    admin:
      enabled: 'false # Whether to enable admin features for the application.'
      jmx-name: 'org.springframework.boot:type=Admin,name=SpringApplication # JMX
        name of the application admin MBean.'
    name: '# Application name.'
  artemis:
    embedded:
      cluster-password: '# Cluster password. Randomly generated on startup by default.'
      data-directory: '# Journal file directory. Not necessary if persistence is turned
        off.'
      enabled: 'true # Whether to enable embedded mode if the Artemis server APIs
        are available.'
      persistent: 'false # Whether to enable persistent store.'
      queues: '# Comma-separated list of queues to create on startup.'
      server-id: '# Server ID. By default, an auto-incremented counter is used.'
      topics: '# Comma-separated list of topics to create on startup.'
    host: 'localhost # Artemis broker host.'
    mode: '# Artemis deployment mode, auto-detected by default.'
    password: '# Login password of the broker.'
    pool:
      block-if-full: 'true # Whether to block when a connection is requested and the
        pool is full. Set it to false to throw a "JMSException" instead.'
      block-if-full-timeout: '-1ms # Blocking period before throwing an exception
        if the pool is still full.'
      enabled: 'false # Whether a JmsPoolConnectionFactory should be created, instead
        of a regular ConnectionFactory.'
      idle-timeout: '30s # Connection idle timeout.'
      max-connections: '1 # Maximum number of pooled connections.'
      max-sessions-per-connection: '500 # Maximum number of pooled sessions per connection
        in the pool.'
      time-between-expiration-check: '-1ms # Time to sleep between runs of the idle
        connection eviction thread. When negative, no idle connection eviction thread
        runs.'
      use-anonymous-producers: 'true # Whether to use only one anonymous "MessageProducer"
        instance. Set it to false to create one "MessageProducer" every time one is
        required.'
    port: '61616 # Artemis broker port.'
    user: '# Login user of the broker.'
  autoconfigure:
    exclude: '# Auto-configuration classes to exclude.'
  banner:
    charset: 'UTF-8 # Banner file encoding.'
    image:
      height: '# Height of the banner image in chars (default based on image height).'
      invert: 'false # Whether images should be inverted for dark terminal themes.'
      location: 'classpath:banner.gif # Banner image file location (jpg or png can
        also be used).'
      margin: '2 # Left hand image margin in chars.'
      width: '76 # Width of the banner image in chars.'
    location: 'classpath:banner.txt # Banner text resource location.'
  batch:
    initialize-schema: 'embedded # Database schema initialization mode.'
    job:
      enabled: 'true # Execute all Spring Batch jobs in the context on startup.'
      names: '# Comma-separated list of job names to execute on startup (for instance,
        `job1,job2`). By default, all Jobs found in the context are executed.'
    schema: 'classpath:org/springframework/batch/core/schema-@@platform@@.sql # Path
      to the SQL file to use to initialize the database schema.'
    table-prefix: '# Table prefix for all the batch meta-data tables.'
  beaninfo:
    ignore: 'true # Whether to skip search of BeanInfo classes.'
  cache:
    cache-names: '# Comma-separated list of cache names to create if supported by
      the underlying cache manager.'
    caffeine:
      spec: '# The spec to use to create caches. See CaffeineSpec for more details
        on the spec format.'
    couchbase:
      expiration: '# Entry expiration. By default the entries never expire. Note that
        this value is ultimately converted to seconds.'
    ehcache:
      config: '# The location of the configuration file to use to initialize EhCache.'
    infinispan:
      config: '# The location of the configuration file to use to initialize Infinispan.'
    jcache:
      config: '# The location of the configuration file to use to initialize the cache
        manager.'
      provider: '# Fully qualified name of the CachingProvider implementation to use
        to retrieve the JSR-107 compliant cache manager. Needed only if more than
        one JSR-107 implementation is available on the classpath.'
    redis:
      cache-null-values: 'true # Allow caching null values.'
      key-prefix: '# Key prefix.'
      time-to-live: '# Entry expiration. By default the entries never expire.'
      use-key-prefix: 'true # Whether to use the key prefix when writing to Redis.'
    type: '# Cache type. By default, auto-detected according to the environment.'
  config:
    additional-location: '# Config file locations used in addition to the defaults.'
    location: '# Config file locations that replace the defaults.'
    name: 'application # Config file name.'
  couchbase:
    bootstrap-hosts: '# Couchbase nodes (host or IP address) to bootstrap from.'
    bucket:
      name: 'default # Name of the bucket to connect to.'
      password: '# Password of the bucket.'
    env:
      endpoints:
        key-value: '1 # Number of sockets per node against the key/value service.'
        queryservice:
          max-endpoints: '1 # Maximum number of sockets per node.'
          min-endpoints: '1 # Minimum number of sockets per node.'
        viewservice:
          max-endpoints: '1 # Maximum number of sockets per node.'
          min-endpoints: '1 # Minimum number of sockets per node.'
      ssl:
        enabled: '# Whether to enable SSL support. Enabled automatically if a "keyStore"
          is provided unless specified otherwise.'
        key-store: '# Path to the JVM key store that holds the certificates.'
        key-store-password: '# Password used to access the key store.'
      timeouts:
        connect: '5000ms # Bucket connections timeouts.'
        key-value: '2500ms # Blocking operations performed on a specific key timeout.'
        query: '7500ms # N1QL query operations timeout.'
        socket-connect: '1000ms # Socket connect connections timeout.'
        view: '7500ms # Regular and geospatial view operations timeout.'
  dao:
    exceptiontranslation:
      enabled: 'true # Whether to enable the PersistenceExceptionTranslationPostProcessor.'
  data:
    cassandra:
      cluster-name: '# Name of the Cassandra cluster.'
      compression: 'none # Compression supported by the Cassandra binary protocol.'
      connect-timeout: '# Socket option: connection time out.'
      consistency-level: '# Queries consistency level.'
      contact-points: 'localhost # Cluster node addresses.'
      fetch-size: '# Queries default fetch size.'
      jmx-enabled: 'false # Whether to enable JMX reporting.'
      keyspace-name: '# Keyspace name to use.'
      password: '# Login password of the server.'
      pool:
        heartbeat-interval: '30s # Heartbeat interval after which a message is sent
          on an idle connection to make sure it''s still alive. If a duration suffix
          is not specified, seconds will be used.'
        idle-timeout: '120s # Idle timeout before an idle connection is removed. If
          a duration suffix is not specified, seconds will be used.'
        max-queue-size: '256 # Maximum number of requests that get queued if no connection
          is available.'
        pool-timeout: '5000ms # Pool timeout when trying to acquire a connection from
          a host''s pool.'
      port: '# Port of the Cassandra server.'
      read-timeout: '# Socket option: read time out.'
      repositories:
        type: 'auto # Type of Cassandra repositories to enable.'
      schema-action: 'none # Schema action to take at startup.'
      serial-consistency-level: '# Queries serial consistency level.'
      ssl: 'false # Enable SSL support.'
      username: '# Login user of the server.'
    couchbase:
      auto-index: 'false # Automatically create views and indexes.'
      consistency: 'read-your-own-writes # Consistency to apply by default on generated
        queries.'
      repositories:
        type: 'auto # Type of Couchbase repositories to enable.'
    elasticsearch:
      cluster-name: 'elasticsearch # Elasticsearch cluster name.'
      cluster-nodes: '# Comma-separated list of cluster node addresses.'
      properties:
        '*': '# Additional properties used to configure the client.'
      repositories:
        enabled: 'true # Whether to enable Elasticsearch repositories.'
    jdbc:
      repositories:
        enabled: 'true # Whether to enable JDBC repositories.'
    jpa:
      repositories:
        bootstrap-mode: 'default # Bootstrap mode for JPA repositories.'
        enabled: 'true # Whether to enable JPA repositories.'
    ldap:
      repositories:
        enabled: 'true # Whether to enable LDAP repositories.'
    mongodb:
      authentication-database: '# Authentication database name.'
      database: '# Database name.'
      field-naming-strategy: '# Fully qualified name of the FieldNamingStrategy to
        use.'
      grid-fs-database: '# GridFS database name.'
      host: '# Mongo server host. Cannot be set with URI.'
      password: '# Login password of the mongo server. Cannot be set with URI.'
      port: '# Mongo server port. Cannot be set with URI.'
      repositories:
        type: 'auto # Type of Mongo repositories to enable.'
      uri: 'mongodb://localhost/test # Mongo database URI. Cannot be set with host,
        port and credentials.'
      username: '# Login user of the mongo server. Cannot be set with URI.'
    neo4j:
      auto-index: 'none # Auto index mode.'
      embedded:
        enabled: 'true # Whether to enable embedded mode if the embedded driver is
          available.'
      open-in-view: 'true # Register OpenSessionInViewInterceptor. Binds a Neo4j Session
        to the thread for the entire processing of the request.'
      password: '# Login password of the server.'
      repositories:
        enabled: 'true # Whether to enable Neo4j repositories.'
      uri: '# URI used by the driver. Auto-detected by default.'
      username: '# Login user of the server.'
    redis:
      repositories:
        enabled: 'true # Whether to enable Redis repositories.'
    rest:
      base-path: '# Base path to be used by Spring Data REST to expose repository
        resources.'
      default-media-type: '# Content type to use as a default when none is specified.'
      default-page-size: '# Default size of pages.'
      detection-strategy: 'default # Strategy to use to determine which repositories
        get exposed.'
      enable-enum-translation: '# Whether to enable enum value translation through
        the Spring Data REST default resource bundle.'
      limit-param-name: '# Name of the URL query string parameter that indicates how
        many results to return at once.'
      max-page-size: '# Maximum size of pages.'
      page-param-name: '# Name of the URL query string parameter that indicates what
        page to return.'
      return-body-on-create: '# Whether to return a response body after creating an
        entity.'
      return-body-on-update: '# Whether to return a response body after updating an
        entity.'
      sort-param-name: '# Name of the URL query string parameter that indicates what
        direction to sort results.'
    solr:
      host: 'http://127.0.0.1:8983/solr # Solr host. Ignored if "zk-host" is set.'
      repositories:
        enabled: 'true # Whether to enable Solr repositories.'
      zk-host: '# ZooKeeper host address in the form HOST:PORT.'
    web:
      pageable:
        default-page-size: '20 # Default page size.'
        max-page-size: '2000 # Maximum page size to be accepted.'
        one-indexed-parameters: 'false # Whether to expose and assume 1-based page
          number indexes.'
        page-parameter: 'page # Page index parameter name.'
        prefix: '# General prefix to be prepended to the page number and page size
          parameters.'
        qualifier-delimiter: '_ # Delimiter to be used between the qualifier and the
          actual page number and size properties.'
        size-parameter: 'size # Page size parameter name.'
      sort:
        sort-parameter: 'sort # Sort parameter name.'
  datasource:
    continue-on-error: 'false # Whether to stop if an error occurs while initializing
      the database.'
    data: '# Data (DML) script resource references.'
    data-password: '# Password of the database to execute DML scripts (if different).'
    data-username: '# Username of the database to execute DML scripts (if different).'
    dbcp2:
      '*': '# Commons DBCP2 specific settings'
    driver-class-name: '# Fully qualified name of the JDBC driver. Auto-detected based
      on the URL by default.'
    generate-unique-name: 'false # Whether to generate a random datasource name.'
    hikari:
      '*': '# Hikari specific settings'
    initialization-mode: 'embedded # Initialize the datasource with available DDL
      and DML scripts.'
    jmx-enabled: 'false # Whether to enable JMX support (if provided by the underlying
      pool).'
    jndi-name: '# JNDI location of the datasource. Class, url, username & password
      are ignored when set.'
    name: '# Name of the datasource. Default to "testdb" when using an embedded database.'
    password: '# Login password of the database.'
    platform: 'all # Platform to use in the DDL or DML scripts (such as schema-${platform}.sql
      or data-${platform}.sql).'
    schema: '# Schema (DDL) script resource references.'
    schema-password: '# Password of the database to execute DDL scripts (if different).'
    schema-username: '# Username of the database to execute DDL scripts (if different).'
    separator: '; # Statement separator in SQL initialization scripts.'
    sql-script-encoding: '# SQL scripts encoding.'
    tomcat:
      '*': '# Tomcat datasource specific settings'
    type: '# Fully qualified name of the connection pool implementation to use. By
      default, it is auto-detected from the classpath.'
    url: '# JDBC URL of the database.'
    username: '# Login username of the database.'
    xa:
      data-source-class-name: '# XA datasource fully qualified name.'
      properties: '# Properties to pass to the XA data source.'
  devtools:
    add-properties: 'true # Whether to enable development property defaults.'
    livereload:
      enabled: 'true # Whether to enable a livereload.com-compatible server.'
      port: '35729 # Server port.'
    remote:
      context-path: '/.~~spring-boot!~ # Context path used to handle the remote connection.'
      proxy:
        host: '# The host of the proxy to use to connect to the remote application.'
        port: '# The port of the proxy to use to connect to the remote application.'
      restart:
        enabled: 'true # Whether to enable remote restart.'
      secret: '# A shared secret required to establish a connection (required to enable
        remote support).'
      secret-header-name: 'X-AUTH-TOKEN # HTTP header used to transfer the shared
        secret.'
    restart:
      additional-exclude: '# Additional patterns that should be excluded from triggering
        a full restart.'
      additional-paths: '# Additional paths to watch for changes.'
      enabled: 'true # Whether to enable automatic restart.'
      exclude: 'META-INF/maven/**,META-INF/resources/**,resources/**,static/**,public/**,templates/**,**/*Test.class,**/*Tests.class,git.properties,META-INF/build-info.properties
        # Patterns that should be excluded from triggering a full restart.'
      log-condition-evaluation-delta: 'true # Whether to log the condition evaluation
        delta upon restart.'
      poll-interval: '1s # Amount of time to wait between polling for classpath changes.'
      quiet-period: '400ms # Amount of quiet time required without any classpath changes
        before a restart is triggered.'
      trigger-file: '# Name of a specific file that, when changed, triggers the restart
        check. If not specified, any classpath file change triggers the restart.'
  elasticsearch:
    jest:
      connection-timeout: '3s # Connection timeout.'
      multi-threaded: 'true # Whether to enable connection requests from multiple
        execution threads.'
      password: '# Login password.'
      proxy:
        host: '# Proxy host the HTTP client should use.'
        port: '# Proxy port the HTTP client should use.'
      read-timeout: '3s # Read timeout.'
      uris: 'http://localhost:9200 # Comma-separated list of the Elasticsearch instances
        to use.'
      username: '# Login username.'
    rest:
      password: '# Credentials password.'
      uris: 'http://localhost:9200 # Comma-separated list of the Elasticsearch instances
        to use.'
      username: '# Credentials username.'
  flyway:
    baseline-description: '<< Flyway Baseline >> # Description to tag an existing
      schema with when applying a baseline.'
    baseline-on-migrate: 'false # Whether to automatically call baseline when migrating
      a non-empty schema.'
    baseline-version: '1 # Version to tag an existing schema with when executing baseline.'
    check-location: 'true # Whether to check that migration scripts location exists.'
    clean-disabled: 'false # Whether to disable cleaning of the database.'
    clean-on-validation-error: 'false # Whether to automatically call clean when a
      validation error occurs.'
    connect-retries: '0 # Maximum number of retries when attempting to connect to
      the database.'
    enabled: 'true # Whether to enable flyway.'
    encoding: 'UTF-8 # Encoding of SQL migrations.'
    group: 'false # Whether to group all pending migrations together in the same transaction
      when applying them.'
    ignore-future-migrations: 'true # Whether to ignore future migrations when reading
      the schema history table.'
    ignore-ignored-migrations: 'false # Whether to ignore ignored migrations when
      reading the schema history table.'
    ignore-missing-migrations: 'false # Whether to ignore missing migrations when
      reading the schema history table.'
    ignore-pending-migrations: 'false # Whether to ignore pending migrations when
      reading the schema history table.'
    init-sqls: '# SQL statements to execute to initialize a connection immediately
      after obtaining it.'
    installed-by: '# Username recorded in the schema history table as having applied
      the migration.'
    locations: 'classpath:db/migration # Locations of migrations scripts. Can contain
      the special "{vendor}" placeholder to use vendor-specific locations.'
    mixed: 'false # Whether to allow mixing transactional and non-transactional statements
      within the same migration.'
    out-of-order: 'false # Whether to allow migrations to be run out of order.'
    password: '# Login password of the database to migrate.'
    placeholder-prefix: '${ # Prefix of placeholders in migration scripts.'
    placeholder-replacement: 'true # Perform placeholder replacement in migration
      scripts.'
    placeholder-suffix: '} # Suffix of placeholders in migration scripts.'
    placeholders: '# Placeholders and their replacements to apply to sql migration
      scripts.'
    repeatable-sql-migration-prefix: 'R # File name prefix for repeatable SQL migrations.'
    schemas: '# Scheme names managed by Flyway (case-sensitive).'
    skip-default-callbacks: 'false # Whether to skip default callbacks. If true, only
      custom callbacks are used.'
    skip-default-resolvers: 'false # Whether to skip default resolvers. If true, only
      custom resolvers are used.'
    sql-migration-prefix: 'V # File name prefix for SQL migrations.'
    sql-migration-separator: '__ # File name separator for SQL migrations.'
    sql-migration-suffixes: '.sql # File name suffix for SQL migrations.'
    table: 'flyway_schema_history # Name of the schema schema history table that will
      be used by Flyway.'
    target: '# Target version up to which migrations should be considered.'
    url: '# JDBC url of the database to migrate. If not set, the primary configured
      data source is used.'
    user: '# Login user of the database to migrate.'
    validate-on-migrate: 'true # Whether to automatically call validate when performing
      a migration.'
  freemarker:
    allow-request-override: 'false # Whether HttpServletRequest attributes are allowed
      to override (hide) controller generated model attributes of the same name.'
    allow-session-override: 'false # Whether HttpSession attributes are allowed to
      override (hide) controller generated model attributes of the same name.'
    cache: 'false # Whether to enable template caching.'
    charset: 'UTF-8 # Template encoding.'
    check-template-location: 'true # Whether to check that the templates location
      exists.'
    content-type: 'text/html # Content-Type value.'
    enabled: 'true # Whether to enable MVC view resolution for this technology.'
    expose-request-attributes: 'false # Whether all request attributes should be added
      to the model prior to merging with the template.'
    expose-session-attributes: 'false # Whether all HttpSession attributes should
      be added to the model prior to merging with the template.'
    expose-spring-macro-helpers: 'true # Whether to expose a RequestContext for use
      by Spring''s macro library, under the name "springMacroRequestContext".'
    prefer-file-system-access: 'true # Whether to prefer file system access for template
      loading. File system access enables hot detection of template changes.'
    prefix: '# Prefix that gets prepended to view names when building a URL.'
    request-context-attribute: '# Name of the RequestContext attribute for all views.'
    settings:
      '*': '# Well-known FreeMarker keys which are passed to FreeMarker''s Configuration.'
    suffix: '.ftl # Suffix that gets appended to view names when building a URL.'
    template-loader-path: 'classpath:/templates/ # Comma-separated list of template
      paths.'
    view-names: '# White list of view names that can be resolved.'
  groovy:
    template:
      allow-request-override: 'false # Whether HttpServletRequest attributes are allowed
        to override (hide) controller generated model attributes of the same name.'
      allow-session-override: 'false # Whether HttpSession attributes are allowed
        to override (hide) controller generated model attributes of the same name.'
      cache: 'false # Whether to enable template caching.'
      charset: 'UTF-8 # Template encoding.'
      check-template-location: 'true # Whether to check that the templates location
        exists.'
      configuration:
        '*': '# See GroovyMarkupConfigurer'
      content-type: 'text/html # Content-Type value.'
      enabled: 'true # Whether to enable MVC view resolution for this technology.'
      expose-request-attributes: 'false # Whether all request attributes should be
        added to the model prior to merging with the template.'
      expose-session-attributes: 'false # Whether all HttpSession attributes should
        be added to the model prior to merging with the template.'
      expose-spring-macro-helpers: 'true # Whether to expose a RequestContext for
        use by Spring''s macro library, under the name "springMacroRequestContext".'
      prefix: '# Prefix that gets prepended to view names when building a URL.'
      request-context-attribute: '# Name of the RequestContext attribute for all views.'
      resource-loader-path: 'classpath:/templates/ # Template path.'
      suffix: '.tpl # Suffix that gets appended to view names when building a URL.'
      view-names: '# White list of view names that can be resolved.'
  gson:
    date-format: '# Format to use when serializing Date objects.'
    disable-html-escaping: '# Whether to disable the escaping of HTML characters such
      as ''<'', ''>'', etc.'
    disable-inner-class-serialization: '# Whether to exclude inner classes during
      serialization.'
    enable-complex-map-key-serialization: '# Whether to enable serialization of complex
      map keys (i.e. non-primitives).'
    exclude-fields-without-expose-annotation: '# Whether to exclude all fields from
      consideration for serialization or deserialization that do not have the "Expose"
      annotation.'
    field-naming-policy: '# Naming policy that should be applied to an object''s field
      during serialization and deserialization.'
    generate-non-executable-json: '# Whether to generate non executable JSON by prefixing
      the output with some special text.'
    lenient: '# Whether to be lenient about parsing JSON that doesn''t conform to
      RFC 4627.'
    long-serialization-policy: '# Serialization policy for Long and long types.'
    pretty-printing: '# Whether to output serialized JSON that fits in a page for
      pretty printing.'
    serialize-nulls: '# Whether to serialize null fields.'
  h2:
    console:
      enabled: 'false # Whether to enable the console.'
      path: '/h2-console # Path at which the console is available.'
      settings:
        trace: 'false # Whether to enable trace output.'
        web-allow-others: 'false # Whether to enable remote access.'
  hateoas:
    use-hal-as-default-json-media-type: 'true # Whether application/hal+json responses
      should be sent to requests that accept application/json.'
  hazelcast:
    config: '# The location of the configuration file to use to initialize Hazelcast.'
  http:
    converters:
      preferred-json-mapper: '# Preferred JSON mapper to use for HTTP message conversion.
        By default, auto-detected according to the environment.'
    encoding:
      charset: 'UTF-8 # Charset of HTTP requests and responses. Added to the "Content-Type"
        header if not set explicitly.'
      enabled: 'true # Whether to enable http encoding support.'
      force: '# Whether to force the encoding to the configured charset on HTTP requests
        and responses.'
      force-request: '# Whether to force the encoding to the configured charset on
        HTTP requests. Defaults to true when "force" has not been specified.'
      force-response: '# Whether to force the encoding to the configured charset on
        HTTP responses.'
      mapping: '# Locale in which to encode mapping.'
    log-request-details: 'false # Whether logging of (potentially sensitive) request
      details at DEBUG and TRACE level is allowed.'
  influx:
    password: '# Login password.'
    url: '# URL of the InfluxDB instance to which to connect.'
    user: '# Login user.'
  info:
    build:
      encoding: 'UTF-8 # File encoding.'
      location: 'classpath:META-INF/build-info.properties # Location of the generated
        build-info.properties file.'
    git:
      encoding: 'UTF-8 # File encoding.'
      location: 'classpath:git.properties # Location of the generated git.properties
        file.'
  integration:
    jdbc:
      initialize-schema: 'embedded # Database schema initialization mode.'
      schema: 'classpath:org/springframework/integration/jdbc/schema-@@platform@@.sql
        # Path to the SQL file to use to initialize the database schema.'
  jackson:
    date-format: '# Date format string or a fully-qualified date format class name.
      For instance, `yyyy-MM-dd HH:mm:ss`.'
    default-property-inclusion: '# Controls the inclusion of properties during serialization.
      Configured with one of the values in Jackson''s JsonInclude.Include enumeration.'
    deserialization:
      '*': '# Jackson on/off features that affect the way Java objects are deserialized.'
    generator:
      '*': '# Jackson on/off features for generators.'
    joda-date-time-format: '# Joda date time format string. If not configured, "date-format"
      is used as a fallback if it is configured with a format string.'
    locale: '# Locale used for formatting.'
    mapper:
      '*': '# Jackson general purpose on/off features.'
    parser:
      '*': '# Jackson on/off features for parsers.'
    property-naming-strategy: '# One of the constants on Jackson''s PropertyNamingStrategy.
      Can also be a fully-qualified class name of a PropertyNamingStrategy subclass.'
    serialization:
      '*': '# Jackson on/off features that affect the way Java objects are serialized.'
    time-zone: '#  Time zone used when formatting dates. For instance, "America/Los_Angeles"
      or "GMT+10".'
    visibility:
      '*': '# Jackson visibility thresholds that can be used to limit which methods
        (and fields) are auto-detected.'
  jdbc:
    template:
      fetch-size: '-1 # Number of rows that should be fetched from the database when
        more rows are needed.'
      max-rows: '-1 # Maximum number of rows.'
      query-timeout: '# Query timeout. Default is to use the JDBC driver''s default
        configuration. If a duration suffix is not specified, seconds will be used.'
  jersey:
    application-path: '# Path that serves as the base URI for the application. If
      specified, overrides the value of "@ApplicationPath".'
    filter:
      order: '0 # Jersey filter chain order.'
    init:
      '*': '# Init parameters to pass to Jersey through the servlet or filter.'
    servlet:
      load-on-startup: '-1 # Load on startup priority of the Jersey servlet.'
    type: 'servlet # Jersey integration type.'
  jms:
    cache:
      consumers: 'false # Whether to cache message consumers.'
      enabled: 'true # Whether to cache sessions.'
      producers: 'true # Whether to cache message producers.'
      session-cache-size: '1 # Size of the session cache (per JMS Session type).'
    jndi-name: '# Connection factory JNDI name. When set, takes precedence to others
      connection factory auto-configurations.'
    listener:
      acknowledge-mode: '# Acknowledge mode of the container. By default, the listener
        is transacted with automatic acknowledgment.'
      auto-startup: 'true # Start the container automatically on startup.'
      concurrency: '# Minimum number of concurrent consumers.'
      max-concurrency: '# Maximum number of concurrent consumers.'
    pub-sub-domain: 'false # Whether the default destination type is topic.'
    template:
      default-destination: '# Default destination to use on send and receive operations
        that do not have a destination parameter.'
      delivery-delay: '# Delivery delay to use for send calls.'
      delivery-mode: '# Delivery mode. Enables QoS (Quality of Service) when set.'
      priority: '# Priority of a message when sending. Enables QoS (Quality of Service)
        when set.'
      qos-enabled: '# Whether to enable explicit QoS (Quality of Service) when sending
        a message.'
      receive-timeout: '# Timeout to use for receive calls.'
      time-to-live: '# Time-to-live of a message when sending. Enables QoS (Quality
        of Service) when set.'
  jmx:
    default-domain: '# JMX domain name.'
    enabled: 'true # Expose management beans to the JMX domain.'
    server: 'mbeanServer # MBeanServer bean name.'
    unique-names: 'false # Whether unique runtime object names should be ensured.'
  jooq:
    sql-dialect: '# SQL dialect to use. Auto-detected by default.'
  jpa:
    database: '# Target database to operate on, auto-detected by default. Can be alternatively
      set using the "databasePlatform" property.'
    database-platform: '# Name of the target database to operate on, auto-detected
      by default. Can be alternatively set using the "Database" enum.'
    generate-ddl: 'false # Whether to initialize the schema on startup.'
    hibernate:
      ddl-auto: '# DDL mode. This is actually a shortcut for the "hibernate.hbm2ddl.auto"
        property. Defaults to "create-drop" when using an embedded database and no
        schema manager was detected. Otherwise, defaults to "none".'
      naming:
        implicit-strategy: '# Fully qualified name of the implicit naming strategy.'
        physical-strategy: '# Fully qualified name of the physical naming strategy.'
      use-new-id-generator-mappings: '# Whether to use Hibernate''s newer IdentifierGenerator
        for AUTO, TABLE and SEQUENCE.'
    mapping-resources: '# Mapping resources (equivalent to "mapping-file" entries
      in persistence.xml).'
    open-in-view: 'true # Register OpenEntityManagerInViewInterceptor. Binds a JPA
      EntityManager to the thread for the entire processing of the request.'
    properties:
      '*': '# Additional native properties to set on the JPA provider.'
    show-sql: 'false # Whether to enable logging of SQL statements.'
  jta:
    atomikos:
      connectionfactory:
        borrow-connection-timeout: '30 # Timeout, in seconds, for borrowing connections
          from the pool.'
        ignore-session-transacted-flag: 'true # Whether to ignore the transacted flag
          when creating session.'
        local-transaction-mode: 'false # Whether local transactions are desired.'
        maintenance-interval: '60 # The time, in seconds, between runs of the pool''s
          maintenance thread.'
        max-idle-time: '60 # The time, in seconds, after which connections are cleaned
          up from the pool.'
        max-lifetime: '0 # The time, in seconds, that a connection can be pooled for
          before being destroyed. 0 denotes no limit.'
        max-pool-size: '1 # The maximum size of the pool.'
        min-pool-size: '1 # The minimum size of the pool.'
        reap-timeout: '0 # The reap timeout, in seconds, for borrowed connections.
          0 denotes no limit.'
        unique-resource-name: 'jmsConnectionFactory # The unique name used to identify
          the resource during recovery.'
        xa-connection-factory-class-name: '# Vendor-specific implementation of XAConnectionFactory.'
        xa-properties: '# Vendor-specific XA properties.'
      datasource:
        borrow-connection-timeout: '30 # Timeout, in seconds, for borrowing connections
          from the pool.'
        concurrent-connection-validation: '# Whether to use concurrent connection
          validation.'
        default-isolation-level: '# Default isolation level of connections provided
          by the pool.'
        login-timeout: '# Timeout, in seconds, for establishing a database connection.'
        maintenance-interval: '60 # The time, in seconds, between runs of the pool''s
          maintenance thread.'
        max-idle-time: '60 # The time, in seconds, after which connections are cleaned
          up from the pool.'
        max-lifetime: '0 # The time, in seconds, that a connection can be pooled for
          before being destroyed. 0 denotes no limit.'
        max-pool-size: '1 # The maximum size of the pool.'
        min-pool-size: '1 # The minimum size of the pool.'
        reap-timeout: '0 # The reap timeout, in seconds, for borrowed connections.
          0 denotes no limit.'
        test-query: '# SQL query or statement used to validate a connection before
          returning it.'
        unique-resource-name: 'dataSource # The unique name used to identify the resource
          during recovery.'
        xa-data-source-class-name: '# Vendor-specific implementation of XAConnectionFactory.'
        xa-properties: '# Vendor-specific XA properties.'
      properties:
        allow-sub-transactions: 'true # Specify whether sub-transactions are allowed.'
        checkpoint-interval: '500 # Interval between checkpoints, expressed as the
          number of log writes between two checkpoints.'
        default-jta-timeout: '10000ms # Default timeout for JTA transactions.'
        default-max-wait-time-on-shutdown: '9223372036854775807 # How long should
          normal shutdown (no-force) wait for transactions to complete.'
        enable-logging: 'true # Whether to enable disk logging.'
        force-shutdown-on-vm-exit: 'false # Whether a VM shutdown should trigger forced
          shutdown of the transaction core.'
        log-base-dir: '# Directory in which the log files should be stored.'
        log-base-name: 'tmlog # Transactions log file base name.'
        max-actives: '50 # Maximum number of active transactions.'
        max-timeout: '300000ms # Maximum timeout that can be allowed for transactions.'
        recovery:
          delay: '10000ms # Delay between two recovery scans.'
          forget-orphaned-log-entries-delay: '86400000ms # Delay after which recovery
            can cleanup pending (''orphaned'') log entries.'
          max-retries: '5 # Number of retry attempts to commit the transaction before
            throwing an exception.'
          retry-interval: '10000ms # Delay between retry attempts.'
        serial-jta-transactions: 'true # Whether sub-transactions should be joined
          when possible.'
        service: '# Transaction manager implementation that should be started.'
        threaded-two-phase-commit: 'false # Whether to use different (and concurrent)
          threads for two-phase commit on the participating resources.'
        transaction-manager-unique-name: '# The transaction manager''s unique name.'
    bitronix:
      connectionfactory:
        acquire-increment: '1 # Number of connections to create when growing the pool.'
        acquisition-interval: '1 # Time, in seconds, to wait before trying to acquire
          a connection again after an invalid connection was acquired.'
        acquisition-timeout: '30 # Timeout, in seconds, for acquiring connections
          from the pool.'
        allow-local-transactions: 'true # Whether the transaction manager should allow
          mixing XA and non-XA transactions.'
        apply-transaction-timeout: 'false # Whether the transaction timeout should
          be set on the XAResource when it is enlisted.'
        automatic-enlisting-enabled: 'true # Whether resources should be enlisted
          and delisted automatically.'
        cache-producers-consumers: 'true # Whether producers and consumers should
          be cached.'
        class-name: '# Underlying implementation class name of the XA resource.'
        defer-connection-release: 'true # Whether the provider can run many transactions
          on the same connection and supports transaction interleaving.'
        disabled: '# Whether this resource is disabled, meaning it''s temporarily
          forbidden to acquire a connection from its pool.'
        driver-properties: '# Properties that should be set on the underlying implementation.'
        failed: '# Mark this resource producer as failed.'
        ignore-recovery-failures: 'false # Whether recovery failures should be ignored.'
        max-idle-time: '60 # The time, in seconds, after which connections are cleaned
          up from the pool.'
        max-pool-size: '10 # The maximum size of the pool. 0 denotes no limit.'
        min-pool-size: '0 # The minimum size of the pool.'
        password: '# The password to use to connect to the JMS provider.'
        share-transaction-connections: 'false #  Whether connections in the ACCESSIBLE
          state can be shared within the context of a transaction.'
        test-connections: 'true # Whether connections should be tested when acquired
          from the pool.'
        two-pc-ordering-position: '1 # The position that this resource should take
          during two-phase commit (always first is Integer.MIN_VALUE, always last
          is Integer.MAX_VALUE).'
        unique-name: 'jmsConnectionFactory # The unique name used to identify the
          resource during recovery.'
        use-tm-join: 'true # Whether TMJOIN should be used when starting XAResources.'
        user: '# The user to use to connect to the JMS provider.'
      datasource:
        acquire-increment: '1 # Number of connections to create when growing the pool.'
        acquisition-interval: '1 # Time, in seconds, to wait before trying to acquire
          a connection again after an invalid connection was acquired.'
        acquisition-timeout: '30 # Timeout, in seconds, for acquiring connections
          from the pool.'
        allow-local-transactions: 'true # Whether the transaction manager should allow
          mixing XA and non-XA transactions.'
        apply-transaction-timeout: 'false # Whether the transaction timeout should
          be set on the XAResource when it is enlisted.'
        automatic-enlisting-enabled: 'true # Whether resources should be enlisted
          and delisted automatically.'
        class-name: '# Underlying implementation class name of the XA resource.'
        cursor-holdability: '# The default cursor holdability for connections.'
        defer-connection-release: 'true # Whether the database can run many transactions
          on the same connection and supports transaction interleaving.'
        disabled: '# Whether this resource is disabled, meaning it''s temporarily
          forbidden to acquire a connection from its pool.'
        driver-properties: '# Properties that should be set on the underlying implementation.'
        enable-jdbc4-connection-test: '# Whether Connection.isValid() is called when
          acquiring a connection from the pool.'
        failed: '# Mark this resource producer as failed.'
        ignore-recovery-failures: 'false # Whether recovery failures should be ignored.'
        isolation-level: '# The default isolation level for connections.'
        local-auto-commit: '# The default auto-commit mode for local transactions.'
        login-timeout: '# Timeout, in seconds, for establishing a database connection.'
        max-idle-time: '60 # The time, in seconds, after which connections are cleaned
          up from the pool.'
        max-pool-size: '10 # The maximum size of the pool. 0 denotes no limit.'
        min-pool-size: '0 # The minimum size of the pool.'
        prepared-statement-cache-size: '0 # The target size of the prepared statement
          cache. 0 disables the cache.'
        share-transaction-connections: 'false #  Whether connections in the ACCESSIBLE
          state can be shared within the context of a transaction.'
        test-query: '# SQL query or statement used to validate a connection before
          returning it.'
        two-pc-ordering-position: '1 # The position that this resource should take
          during two-phase commit (always first is Integer.MIN_VALUE, and always last
          is Integer.MAX_VALUE).'
        unique-name: 'dataSource # The unique name used to identify the resource during
          recovery.'
        use-tm-join: 'true # Whether TMJOIN should be used when starting XAResources.'
      properties:
        allow-multiple-lrc: 'false # Whether to allow multiple LRC resources to be
          enlisted into the same transaction.'
        asynchronous2-pc: 'false # Whether to enable asynchronously execution of two
          phase commit.'
        background-recovery-interval-seconds: '60 # Interval in seconds at which to
          run the recovery process in the background.'
        current-node-only-recovery: 'true # Whether to recover only the current node.'
        debug-zero-resource-transaction: 'false # Whether to log the creation and
          commit call stacks of transactions executed without a single enlisted resource.'
        default-transaction-timeout: '60 # Default transaction timeout, in seconds.'
        disable-jmx: 'false # Whether to enable JMX support.'
        exception-analyzer: '# Set the fully qualified name of the exception analyzer
          implementation to use.'
        filter-log-status: 'false # Whether to enable filtering of logs so that only
          mandatory logs are written.'
        force-batching-enabled: 'true #  Whether disk forces are batched.'
        forced-write-enabled: 'true # Whether logs are forced to disk.'
        graceful-shutdown-interval: '60 # Maximum amount of seconds the TM waits for
          transactions to get done before aborting them at shutdown time.'
        jndi-transaction-synchronization-registry-name: '# JNDI name of the TransactionSynchronizationRegistry.'
        jndi-user-transaction-name: '# JNDI name of the UserTransaction.'
        journal: 'disk # Name of the journal. Can be ''disk'', ''null'', or a class
          name.'
        log-part1-filename: 'btm1.tlog # Name of the first fragment of the journal.'
        log-part2-filename: 'btm2.tlog # Name of the second fragment of the journal.'
        max-log-size-in-mb: '2 # Maximum size in megabytes of the journal fragments.'
        resource-configuration-filename: '# ResourceLoader configuration file name.'
        server-id: '# ASCII ID that must uniquely identify this TM instance. Defaults
          to the machine''s IP address.'
        skip-corrupted-logs: 'false # Skip corrupted transactions log entries.'
        warn-about-zero-resource-transaction: 'true # Whether to log a warning for
          transactions executed without a single enlisted resource.'
    enabled: 'true # Whether to enable JTA support.'
    log-dir: '# Transaction logs directory.'
    transaction-manager-id: '# Transaction manager unique identifier.'
  kafka:
    admin:
      client-id: '# ID to pass to the server when making requests. Used for server-side
        logging.'
      fail-fast: 'false # Whether to fail fast if the broker is not available on startup.'
      properties:
        '*': '# Additional admin-specific properties used to configure the client.'
      ssl:
        key-password: '# Password of the private key in the key store file.'
        key-store-location: '# Location of the key store file.'
        key-store-password: '# Store password for the key store file.'
        key-store-type: '# Type of the key store.'
        protocol: '# SSL protocol to use.'
        trust-store-location: '# Location of the trust store file.'
        trust-store-password: '# Store password for the trust store file.'
        trust-store-type: '# Type of the trust store.'
    bootstrap-servers: '# Comma-delimited list of host:port pairs to use for establishing
      the initial connections to the Kafka cluster. Applies to all components unless
      overridden.'
    client-id: '# ID to pass to the server when making requests. Used for server-side
      logging.'
    consumer:
      auto-commit-interval: '# Frequency with which the consumer offsets are auto-committed
        to Kafka if ''enable.auto.commit'' is set to true.'
      auto-offset-reset: '# What to do when there is no initial offset in Kafka or
        if the current offset no longer exists on the server.'
      bootstrap-servers: '# Comma-delimited list of host:port pairs to use for establishing
        the initial connections to the Kafka cluster. Overrides the global property,
        for consumers.'
      client-id: '# ID to pass to the server when making requests. Used for server-side
        logging.'
      enable-auto-commit: '# Whether the consumer''s offset is periodically committed
        in the background.'
      fetch-max-wait: '# Maximum amount of time the server blocks before answering
        the fetch request if there isn''t sufficient data to immediately satisfy the
        requirement given by "fetch-min-size".'
      fetch-min-size: '# Minimum amount of data the server should return for a fetch
        request.'
      group-id: '# Unique string that identifies the consumer group to which this
        consumer belongs.'
      heartbeat-interval: '# Expected time between heartbeats to the consumer coordinator.'
      key-deserializer: '# Deserializer class for keys.'
      max-poll-records: '# Maximum number of records returned in a single call to
        poll().'
      properties:
        '*': '# Additional consumer-specific properties used to configure the client.'
      ssl:
        key-password: '# Password of the private key in the key store file.'
        key-store-location: '# Location of the key store file.'
        key-store-password: '# Store password for the key store file.'
        key-store-type: '# Type of the key store.'
        protocol: '# SSL protocol to use.'
        trust-store-location: '# Location of the trust store file.'
        trust-store-password: '# Store password for the trust store file.'
        trust-store-type: '# Type of the trust store.'
      value-deserializer: '# Deserializer class for values.'
    jaas:
      control-flag: 'required # Control flag for login configuration.'
      enabled: 'false # Whether to enable JAAS configuration.'
      login-module: 'com.sun.security.auth.module.Krb5LoginModule # Login module.'
      options: '# Additional JAAS options.'
    listener:
      ack-count: '# Number of records between offset commits when ackMode is "COUNT"
        or "COUNT_TIME".'
      ack-mode: '# Listener AckMode. See the spring-kafka documentation.'
      ack-time: '# Time between offset commits when ackMode is "TIME" or "COUNT_TIME".'
      client-id: '# Prefix for the listener''s consumer client.id property.'
      concurrency: '# Number of threads to run in the listener containers.'
      idle-event-interval: '# Time between publishing idle consumer events (no data
        received).'
      log-container-config: '# Whether to log the container configuration during initialization
        (INFO level).'
      monitor-interval: '# Time between checks for non-responsive consumers. If a
        duration suffix is not specified, seconds will be used.'
      no-poll-threshold: '# Multiplier applied to "pollTimeout" to determine if a
        consumer is non-responsive.'
      poll-timeout: '# Timeout to use when polling the consumer.'
      type: 'single # Listener type.'
    producer:
      acks: '# Number of acknowledgments the producer requires the leader to have
        received before considering a request complete.'
      batch-size: '# Default batch size.'
      bootstrap-servers: '# Comma-delimited list of host:port pairs to use for establishing
        the initial connections to the Kafka cluster. Overrides the global property,
        for producers.'
      buffer-memory: '# Total memory size the producer can use to buffer records waiting
        to be sent to the server.'
      client-id: '# ID to pass to the server when making requests. Used for server-side
        logging.'
      compression-type: '# Compression type for all data generated by the producer.'
      key-serializer: '# Serializer class for keys.'
      properties:
        '*': '# Additional producer-specific properties used to configure the client.'
      retries: '# When greater than zero, enables retrying of failed sends.'
      ssl:
        key-password: '# Password of the private key in the key store file.'
        key-store-location: '# Location of the key store file.'
        key-store-password: '# Store password for the key store file.'
        key-store-type: '# Type of the key store.'
        protocol: '# SSL protocol to use.'
        trust-store-location: '# Location of the trust store file.'
        trust-store-password: '# Store password for the trust store file.'
        trust-store-type: '# Type of the trust store.'
      transaction-id-prefix: '# When non empty, enables transaction support for producer.'
      value-serializer: '# Serializer class for values.'
    properties:
      '*': '# Additional properties, common to producers and consumers, used to configure
        the client.'
    ssl:
      key-password: '# Password of the private key in the key store file.'
      key-store-location: '# Location of the key store file.'
      key-store-password: '# Store password for the key store file.'
      key-store-type: '# Type of the key store.'
      protocol: '# SSL protocol to use.'
      trust-store-location: '# Location of the trust store file.'
      trust-store-password: '# Store password for the trust store file.'
      trust-store-type: '# Type of the trust store.'
    streams:
      application-id: '# Kafka streams application.id property; default spring.application.name.'
      auto-startup: 'true # Whether or not to auto-start the streams factory bean.'
      bootstrap-servers: '# Comma-delimited list of host:port pairs to use for establishing
        the initial connections to the Kafka cluster. Overrides the global property,
        for streams.'
      cache-max-size-buffering: '# Maximum memory size to be used for buffering across
        all threads.'
      client-id: '# ID to pass to the server when making requests. Used for server-side
        logging.'
      properties:
        '*': '# Additional Kafka properties used to configure the streams.'
      replication-factor: '# The replication factor for change log topics and repartition
        topics created by the stream processing application.'
      ssl:
        key-password: '# Password of the private key in the key store file.'
        key-store-location: '# Location of the key store file.'
        key-store-password: '# Store password for the key store file.'
        key-store-type: '# Type of the key store.'
        protocol: '# SSL protocol to use.'
        trust-store-location: '# Location of the trust store file.'
        trust-store-password: '# Store password for the trust store file.'
        trust-store-type: '# Type of the trust store.'
      state-dir: '# Directory location for the state store.'
    template:
      default-topic: '# Default topic to which messages are sent.'
  ldap:
    anonymous-read-only: 'false # Whether read-only operations should use an anonymous
      environment.'
    base: '# Base suffix from which all operations should originate.'
    base-environment:
      '*': '# LDAP specification settings.'
    embedded:
      base-dn: '# List of base DNs.'
      credential:
        password: '# Embedded LDAP password.'
        username: '# Embedded LDAP username.'
      ldif: 'classpath:schema.ldif # Schema (LDIF) script resource reference.'
      port: '0 # Embedded LDAP port.'
      validation:
        enabled: 'true # Whether to enable LDAP schema validation.'
        schema: '# Path to the custom schema.'
    password: '# Login password of the server.'
    urls: '# LDAP URLs of the server.'
    username: '# Login username of the server.'
  liquibase:
    change-log: 'classpath:/db/changelog/db.changelog-master.yaml # Change log configuration
      path.'
    check-change-log-location: 'true # Whether to check that the change log location
      exists.'
    contexts: '# Comma-separated list of runtime contexts to use.'
    database-change-log-lock-table: 'DATABASECHANGELOGLOCK # Name of table to use
      for tracking concurrent Liquibase usage.'
    database-change-log-table: 'DATABASECHANGELOG # Name of table to use for tracking
      change history.'
    default-schema: '# Default database schema.'
    drop-first: 'false # Whether to first drop the database schema.'
    enabled: 'true # Whether to enable Liquibase support.'
    labels: '# Comma-separated list of runtime labels to use.'
    liquibase-schema: '# Schema to use for Liquibase objects.'
    liquibase-tablespace: '# Tablespace to use for Liquibase objects.'
    parameters:
      '*': '# Change log parameters.'
    password: '# Login password of the database to migrate.'
    rollback-file: '# File to which rollback SQL is written when an update is performed.'
    test-rollback-on-update: 'false # Whether rollback should be tested before update
      is performed.'
    url: '# JDBC URL of the database to migrate. If not set, the primary configured
      data source is used.'
    user: '# Login user of the database to migrate.'
  mail:
    default-encoding: 'UTF-8 # Default MimeMessage encoding.'
    host: '# SMTP server host. For instance, `smtp.example.com`.'
    jndi-name: '# Session JNDI name. When set, takes precedence over other Session
      settings.'
    password: '# Login password of the SMTP server.'
    port: '# SMTP server port.'
    properties:
      '*': '# Additional JavaMail Session properties.'
    protocol: 'smtp # Protocol used by the SMTP server.'
    test-connection: 'false # Whether to test that the mail server is available on
      startup.'
    username: '# Login user of the SMTP server.'
  main:
    allow-bean-definition-overriding: 'false # Whether bean definition overriding,
      by registering a definition with the same name as an existing definition, is
      allowed.'
    banner-mode: 'console # Mode used to display the banner when the application runs.'
    sources: '# Sources (class names, package names, or XML resource locations) to
      include in the ApplicationContext.'
    web-application-type: '# Flag to explicitly request a specific type of web application.
      If not set, auto-detected based on the classpath.'
  mandatory-file-encoding: '# Expected character encoding the application must use.'
  messages:
    always-use-message-format: 'false # Whether to always apply the MessageFormat
      rules, parsing even messages without arguments.'
    basename: 'messages # Comma-separated list of basenames (essentially a fully-qualified
      classpath location), each following the ResourceBundle convention with relaxed
      support for slash based locations.'
    cache-duration: '# Loaded resource bundle files cache duration. When not set,
      bundles are cached forever. If a duration suffix is not specified, seconds will
      be used.'
    encoding: 'UTF-8 # Message bundles encoding.'
    fallback-to-system-locale: 'true # Whether to fall back to the system Locale if
      no files for a specific Locale have been found.'
    use-code-as-default-message: 'false # Whether to use the message code as the default
      message instead of throwing a "NoSuchMessageException". Recommended during development
      only.'
  mongodb:
    embedded:
      features: 'sync_delay # Comma-separated list of features to enable.'
      storage:
        database-dir: '# Directory used for data storage.'
        oplog-size: '# Maximum size of the oplog.'
        repl-set-name: '# Name of the replica set.'
      version: '3.5.5 # Version of Mongo to use.'
  mustache:
    allow-request-override: 'false # Whether HttpServletRequest attributes are allowed
      to override (hide) controller generated model attributes of the same name.'
    allow-session-override: 'false # Whether HttpSession attributes are allowed to
      override (hide) controller generated model attributes of the same name.'
    cache: 'false # Whether to enable template caching.'
    charset: 'UTF-8 # Template encoding.'
    check-template-location: 'true # Whether to check that the templates location
      exists.'
    content-type: 'text/html # Content-Type value.'
    enabled: 'true # Whether to enable MVC view resolution for this technology.'
    expose-request-attributes: 'false # Whether all request attributes should be added
      to the model prior to merging with the template.'
    expose-session-attributes: 'false # Whether all HttpSession attributes should
      be added to the model prior to merging with the template.'
    expose-spring-macro-helpers: 'true # Whether to expose a RequestContext for use
      by Spring''s macro library, under the name "springMacroRequestContext".'
    prefix: 'classpath:/templates/ # Prefix to apply to template names.'
    request-context-attribute: '# Name of the RequestContext attribute for all views.'
    suffix: '.mustache # Suffix to apply to template names.'
    view-names: '# White list of view names that can be resolved.'
  mvc:
    async:
      request-timeout: '# Amount of time before asynchronous request handling times
        out.'
    contentnegotiation:
      favor-parameter: 'false # Whether a request parameter ("format" by default)
        should be used to determine the requested media type.'
      favor-path-extension: 'false # Whether the path extension in the URL path should
        be used to determine the requested media type.'
      media-types:
        '*': '# Map file extensions to media types for content negotiation. For instance,
          yml to text/yaml.'
      parameter-name: '# Query parameter name to use when "favor-parameter" is enabled.'
    date-format: '# Date format to use. For instance, `dd/MM/yyyy`.'
    dispatch-options-request: 'true # Whether to dispatch OPTIONS requests to the
      FrameworkServlet doService method.'
    dispatch-trace-request: 'false # Whether to dispatch TRACE requests to the FrameworkServlet
      doService method.'
    favicon:
      enabled: 'true # Whether to enable resolution of favicon.ico.'
    formcontent:
      filter:
        enabled: 'true # Whether to enable Spring''s FormContentFilter.'
    hiddenmethod:
      filter:
        enabled: 'true # Whether to enable Spring''s HiddenHttpMethodFilter.'
    ignore-default-model-on-redirect: 'true # Whether the content of the "default"
      model should be ignored during redirect scenarios.'
    locale: '# Locale to use. By default, this locale is overridden by the "Accept-Language"
      header.'
    locale-resolver: 'accept-header # Define how the locale should be resolved.'
    log-resolved-exception: 'false # Whether to enable warn logging of exceptions
      resolved by a "HandlerExceptionResolver", except for "DefaultHandlerExceptionResolver".'
    message-codes-resolver-format: '# Formatting strategy for message codes. For instance,
      `PREFIX_ERROR_CODE`.'
    pathmatch:
      use-registered-suffix-pattern: 'false # Whether suffix pattern matching should
        work only against extensions registered with "spring.mvc.contentnegotiation.media-types.*".'
      use-suffix-pattern: 'false # Whether to use suffix pattern match (".*") when
        matching patterns to requests.'
    servlet:
      load-on-startup: '-1 # Load on startup priority of the dispatcher servlet.'
      path: '/ # Path of the dispatcher servlet.'
    static-path-pattern: '/** # Path pattern used for static resources.'
    throw-exception-if-no-handler-found: 'false # Whether a "NoHandlerFoundException"
      should be thrown if no Handler was found to process a request.'
    view:
      prefix: '# Spring MVC view prefix.'
      suffix: '# Spring MVC view suffix.'
  output:
    ansi:
      enabled: 'detect # Configures the ANSI output.'
  pid:
    fail-on-write-error: '# Fails if ApplicationPidFileWriter is used but it cannot
      write the PID file.'
    file: '# Location of the PID file to write (if ApplicationPidFileWriter is used).'
  profiles:
    active: '# Comma-separated list of active profiles. Can be overridden by a command
      line switch.'
    include: '# Unconditionally activate the specified comma-separated list of profiles
      (or list of profiles if using YAML).'
  quartz:
    auto-startup: 'true # Whether to automatically start the scheduler after initialization.'
    jdbc:
      comment-prefix: '-- # Prefix for single-line comments in SQL initialization
        scripts.'
      initialize-schema: 'embedded # Database schema initialization mode.'
      schema: 'classpath:org/quartz/impl/jdbcjobstore/tables_@@platform@@.sql # Path
        to the SQL file to use to initialize the database schema.'
    job-store-type: 'memory # Quartz job store type.'
    overwrite-existing-jobs: 'false # Whether configured jobs should overwrite existing
      job definitions.'
    properties:
      '*': '# Additional Quartz Scheduler properties.'
    scheduler-name: 'quartzScheduler # Name of the scheduler.'
    startup-delay: '0s # Delay after which the scheduler is started once initialization
      completes.'
    wait-for-jobs-to-complete-on-shutdown: 'false # Whether to wait for running jobs
      to complete on shutdown.'
  rabbitmq:
    addresses: '# Comma-separated list of addresses to which the client should connect.'
    cache:
      channel:
        checkout-timeout: '# Duration to wait to obtain a channel if the cache size
          has been reached.'
        size: '# Number of channels to retain in the cache.'
      connection:
        mode: 'channel # Connection factory cache mode.'
        size: '# Number of connections to cache.'
    connection-timeout: '# Connection timeout. Set it to zero to wait forever.'
    dynamic: 'true # Whether to create an AmqpAdmin bean.'
    host: 'localhost # RabbitMQ host.'
    listener:
      direct:
        acknowledge-mode: '# Acknowledge mode of container.'
        auto-startup: 'true # Whether to start the container automatically on startup.'
        consumers-per-queue: '# Number of consumers per queue.'
        default-requeue-rejected: '# Whether rejected deliveries are re-queued by
          default.'
        idle-event-interval: '# How often idle container events should be published.'
        missing-queues-fatal: 'false # Whether to fail if the queues declared by the
          container are not available on the broker.'
        prefetch: '# Maximum number of unacknowledged messages that can be outstanding
          at each consumer.'
        retry:
          enabled: 'false # Whether publishing retries are enabled.'
          initial-interval: '1000ms # Duration between the first and second attempt
            to deliver a message.'
          max-attempts: '3 # Maximum number of attempts to deliver a message.'
          max-interval: '10000ms # Maximum duration between attempts.'
          multiplier: '1 # Multiplier to apply to the previous retry interval.'
          stateless: 'true # Whether retries are stateless or stateful.'
      simple:
        acknowledge-mode: '# Acknowledge mode of container.'
        auto-startup: 'true # Whether to start the container automatically on startup.'
        concurrency: '# Minimum number of listener invoker threads.'
        default-requeue-rejected: '# Whether rejected deliveries are re-queued by
          default.'
        idle-event-interval: '# How often idle container events should be published.'
        max-concurrency: '# Maximum number of listener invoker threads.'
        missing-queues-fatal: 'true # Whether to fail if the queues declared by the
          container are not available on the broker and/or whether to stop the container
          if one or more queues are deleted at runtime.'
        prefetch: '# Maximum number of unacknowledged messages that can be outstanding
          at each consumer.'
        retry:
          enabled: 'false # Whether publishing retries are enabled.'
          initial-interval: '1000ms # Duration between the first and second attempt
            to deliver a message.'
          max-attempts: '3 # Maximum number of attempts to deliver a message.'
          max-interval: '10000ms # Maximum duration between attempts.'
          multiplier: '1 # Multiplier to apply to the previous retry interval.'
          stateless: 'true # Whether retries are stateless or stateful.'
        transaction-size: '# Number of messages to be processed between acks when
          the acknowledge mode is AUTO. If larger than prefetch, prefetch will be
          increased to this value.'
      type: 'simple # Listener container type.'
    password: 'guest # Login to authenticate against the broker.'
    port: '5672 # RabbitMQ port.'
    publisher-confirms: 'false # Whether to enable publisher confirms.'
    publisher-returns: 'false # Whether to enable publisher returns.'
    requested-heartbeat: '# Requested heartbeat timeout; zero for none. If a duration
      suffix is not specified, seconds will be used.'
    ssl:
      algorithm: '# SSL algorithm to use. By default, configured by the Rabbit client
        library.'
      enabled: 'false # Whether to enable SSL support.'
      key-store: '# Path to the key store that holds the SSL certificate.'
      key-store-password: '# Password used to access the key store.'
      key-store-type: 'PKCS12 # Key store type.'
      trust-store: '# Trust store that holds SSL certificates.'
      trust-store-password: '# Password used to access the trust store.'
      trust-store-type: 'JKS # Trust store type.'
      validate-server-certificate: 'true # Whether to enable server side certificate
        validation.'
      verify-hostname: 'true # Whether to enable hostname verification.'
    template:
      default-receive-queue: '# Name of the default queue to receive messages from
        when none is specified explicitly.'
      exchange: '# Name of the default exchange to use for send operations.'
      mandatory: '# Whether to enable mandatory messages.'
      receive-timeout: '# Timeout for `receive()` operations.'
      reply-timeout: '# Timeout for `sendAndReceive()` operations.'
      retry:
        enabled: 'false # Whether publishing retries are enabled.'
        initial-interval: '1000ms # Duration between the first and second attempt
          to deliver a message.'
        max-attempts: '3 # Maximum number of attempts to deliver a message.'
        max-interval: '10000ms # Maximum duration between attempts.'
        multiplier: '1 # Multiplier to apply to the previous retry interval.'
      routing-key: '# Value of a default routing key to use for send operations.'
    username: 'guest # Login user to authenticate to the broker.'
    virtual-host: '# Virtual host to use when connecting to the broker.'
  reactor:
    stacktrace-mode:
      enabled: 'false # Whether Reactor should collect stacktrace information at runtime.'
  redis:
    cluster:
      max-redirects: '# Maximum number of redirects to follow when executing commands
        across the cluster.'
      nodes: '# Comma-separated list of "host:port" pairs to bootstrap from.'
    database: '0 # Database index used by the connection factory.'
    host: 'localhost # Redis server host.'
    jedis:
      pool:
        max-active: '8 # Maximum number of connections that can be allocated by the
          pool at a given time. Use a negative value for no limit.'
        max-idle: '8 # Maximum number of "idle" connections in the pool. Use a negative
          value to indicate an unlimited number of idle connections.'
        max-wait: '-1ms # Maximum amount of time a connection allocation should block
          before throwing an exception when the pool is exhausted. Use a negative
          value to block indefinitely.'
        min-idle: '0 # Target for the minimum number of idle connections to maintain
          in the pool. This setting only has an effect if it is positive.'
    lettuce:
      pool:
        max-active: '8 # Maximum number of connections that can be allocated by the
          pool at a given time. Use a negative value for no limit.'
        max-idle: '8 # Maximum number of "idle" connections in the pool. Use a negative
          value to indicate an unlimited number of idle connections.'
        max-wait: '-1ms # Maximum amount of time a connection allocation should block
          before throwing an exception when the pool is exhausted. Use a negative
          value to block indefinitely.'
        min-idle: '0 # Target for the minimum number of idle connections to maintain
          in the pool. This setting only has an effect if it is positive.'
      shutdown-timeout: '100ms # Shutdown timeout.'
    password: '# Login password of the redis server.'
    port: '6379 # Redis server port.'
    sentinel:
      master: '# Name of the Redis server.'
      nodes: '# Comma-separated list of "host:port" pairs.'
    ssl: 'false # Whether to enable SSL support.'
    timeout: '# Connection timeout.'
    url: '# Connection URL. Overrides host, port, and password. User is ignored. Example:
      redis://user:password@example.com:6379'
  resources:
    add-mappings: 'true # Whether to enable default resource handling.'
    cache:
      cachecontrol:
        cache-private: '# Indicate that the response message is intended for a single
          user and must not be stored by a shared cache.'
        cache-public: '# Indicate that any cache may store the response.'
        max-age: '# Maximum time the response should be cached, in seconds if no duration
          suffix is not specified.'
        must-revalidate: '# Indicate that once it has become stale, a cache must not
          use the response without re-validating it with the server.'
        no-cache: '# Indicate that the cached response can be reused only if re-validated
          with the server.'
        no-store: '# Indicate to not cache the response in any case.'
        no-transform: '# Indicate intermediaries (caches and others) that they should
          not transform the response content.'
        proxy-revalidate: '# Same meaning as the "must-revalidate" directive, except
          that it does not apply to private caches.'
        s-max-age: '# Maximum time the response should be cached by shared caches,
          in seconds if no duration suffix is not specified.'
        stale-if-error: '# Maximum time the response may be used when errors are encountered,
          in seconds if no duration suffix is not specified.'
        stale-while-revalidate: '# Maximum time the response can be served after it
          becomes stale, in seconds if no duration suffix is not specified.'
      period: '# Cache period for the resources served by the resource handler. If
        a duration suffix is not specified, seconds will be used.'
    chain:
      cache: 'true # Whether to enable caching in the Resource chain.'
      compressed: 'false # Whether to enable resolution of already compressed resources
        (gzip, brotli).'
      enabled: '# Whether to enable the Spring Resource Handling chain. By default,
        disabled unless at least one strategy has been enabled.'
      html-application-cache: 'false # Whether to enable HTML5 application cache manifest
        rewriting.'
      strategy:
        content:
          enabled: 'false # Whether to enable the content Version Strategy.'
          paths: '/** # Comma-separated list of patterns to apply to the content Version
            Strategy.'
        fixed:
          enabled: 'false # Whether to enable the fixed Version Strategy.'
          paths: '/** # Comma-separated list of patterns to apply to the fixed Version
            Strategy.'
          version: '# Version string to use for the fixed Version Strategy.'
    static-locations: 'classpath:/META-INF/resources/,classpath:/resources/,classpath:/static/,classpath:/public/
      # Locations of static resources.'
  security:
    filter:
      dispatcher-types: 'async,error,request # Security filter chain dispatcher types.'
      order: '-100 # Security filter chain order.'
    oauth2:
      client:
        provider:
          '*': '# OAuth provider details.'
        registration:
          '*': '# OAuth client registrations.'
      resourceserver:
        jwt:
          issuer-uri: '# URI that an OpenID Connect Provider asserts as its Issuer
            Identifier.'
          jwk-set-uri: '# JSON Web Key URI to use to verify the JWT token.'
    user:
      name: 'user # Default user name.'
      password: '# Password for the default user name.'
      roles: '# Granted roles for the default user name.'
  sendgrid:
    api-key: '# SendGrid API key.'
    proxy:
      host: '# SendGrid proxy host.'
      port: '# SendGrid proxy port.'
  servlet:
    multipart:
      enabled: 'true # Whether to enable support of multipart uploads.'
      file-size-threshold: '0B # Threshold after which files are written to disk.'
      location: '# Intermediate location of uploaded files.'
      max-file-size: '1MB # Max file size.'
      max-request-size: '10MB # Max request size.'
      resolve-lazily: 'false # Whether to resolve the multipart request lazily at
        the time of file or parameter access.'
  session:
    hazelcast:
      flush-mode: 'on-save # Sessions flush mode.'
      map-name: 'spring:session:sessions # Name of the map used to store sessions.'
    jdbc:
      cleanup-cron: '0 * * * * * # Cron expression for expired session cleanup job.'
      initialize-schema: 'embedded # Database schema initialization mode.'
      schema: 'classpath:org/springframework/session/jdbc/schema-@@platform@@.sql
        # Path to the SQL file to use to initialize the database schema.'
      table-name: 'SPRING_SESSION # Name of the database table used to store sessions.'
    mongodb:
      collection-name: 'sessions # Collection name used to store sessions.'
    redis:
      cleanup-cron: '0 * * * * * # Cron expression for expired session cleanup job.'
      flush-mode: 'on-save # Sessions flush mode.'
      namespace: 'spring:session # Namespace for keys used to store sessions.'
    servlet:
      filter-dispatcher-types: 'async,error,request # Session repository filter dispatcher
        types.'
      filter-order: '-2147483598 # Session repository filter order.'
    store-type: '# Session store type.'
    timeout: '# Session timeout. If a duration suffix is not specified, seconds will
      be used.'
  task:
    execution:
      pool:
        allow-core-thread-timeout: 'true # Whether core threads are allowed to time
          out. This enables dynamic growing and shrinking of the pool.'
        core-size: '8 # Core number of threads.'
        keep-alive: '60s # Time limit for which threads may remain idle before being
          terminated.'
        max-size: '# Maximum allowed number of threads. If tasks are filling up the
          queue, the pool can expand up to that size to accommodate the load. Ignored
          if the queue is unbounded.'
        queue-capacity: '# Queue capacity. An unbounded capacity does not increase
          the pool and therefore ignores the "max-size" property.'
      thread-name-prefix: 'task- # Prefix to use for the names of newly created threads.'
    scheduling:
      pool:
        size: '1 # Maximum allowed number of threads.'
      thread-name-prefix: 'scheduling- # Prefix to use for the names of newly created
        threads.'
  test:
    database:
      replace: 'any # Type of existing DataSource to replace.'
    mockmvc:
      print: 'default # MVC Print option.'
  thymeleaf:
    cache: 'true # Whether to enable template caching.'
    check-template: 'true # Whether to check that the template exists before rendering
      it.'
    check-template-location: 'true # Whether to check that the templates location
      exists.'
    enable-spring-el-compiler: 'false # Enable the SpringEL compiler in SpringEL expressions.'
    enabled: 'true # Whether to enable Thymeleaf view resolution for Web frameworks.'
    encoding: 'UTF-8 # Template files encoding.'
    excluded-view-names: '# Comma-separated list of view names (patterns allowed)
      that should be excluded from resolution.'
    mode: 'HTML # Template mode to be applied to templates. See also Thymeleaf''s
      TemplateMode enum.'
    prefix: 'classpath:/templates/ # Prefix that gets prepended to view names when
      building a URL.'
    reactive:
      chunked-mode-view-names: '# Comma-separated list of view names (patterns allowed)
        that should be the only ones executed in CHUNKED mode when a max chunk size
        is set.'
      full-mode-view-names: '# Comma-separated list of view names (patterns allowed)
        that should be executed in FULL mode even if a max chunk size is set.'
      max-chunk-size: '0B # Maximum size of data buffers used for writing to the response.'
      media-types: '# Media types supported by the view technology.'
    render-hidden-markers-before-checkboxes: 'false # Whether hidden form inputs acting
      as markers for checkboxes should be rendered before the checkbox element itself.'
    servlet:
      content-type: 'text/html # Content-Type value written to HTTP responses.'
      produce-partial-output-while-processing: 'true # Whether Thymeleaf should start
        writing partial output as soon as possible or buffer until template processing
        is finished.'
    suffix: '.html # Suffix that gets appended to view names when building a URL.'
    template-resolver-order: '# Order of the template resolver in the chain.'
    view-names: '# Comma-separated list of view names (patterns allowed) that can
      be resolved.'
  transaction:
    default-timeout: '# Default transaction timeout. If a duration suffix is not specified,
      seconds will be used.'
    rollback-on-commit-failure: '# Whether to roll back on commit failures.'
  webflux:
    date-format: '# Date format to use. For instance, `dd/MM/yyyy`.'
    hiddenmethod:
      filter:
        enabled: 'true
        # Whether to enable Spring''s HiddenHttpMethodFilter.'
    static-path-pattern: '/** # Path pattern used for static resources.'
  webservices:
    path: '/services # Path that serves as the base URI for the services.'
    servlet:
      init: '# Servlet init parameters to pass to Spring Web Services.'
      load-on-startup: '-1 # Load on startup priority of the Spring Web Services servlet.'
    wsdl-locations: '# Comma-separated list of locations of WSDLs and accompanying
      XSDs to be exposed as beans.'
trace: 'false
# Enable trace logs.'
